# Resumo da Aula sobre Integração de ConfigMap com Deployment no Kubernetes

## Introdução
A aula avança no uso de **ConfigMap** no Kubernetes, focando na integração com o **Deployment** `widget-server`. O objetivo é consumir as variáveis não sensíveis (`BUCKET` e `PUBLIC_URL`) do **ConfigMap** `widget-server-cm` criado anteriormente, substituindo a abordagem manual de definir variáveis de ambiente (`env`) diretamente no **Deployment**. Duas formas de integração são apresentadas: referenciar chaves específicas do **ConfigMap** e injetar todas as variáveis de uma vez. A aula destaca a escalabilidade e boas práticas, preparando o terreno para a próxima aula sobre **Secrets**.

## Contexto
- **ConfigMap Existente**:
  - Nome: `widget-server-cm`
  - Namespace: `widget`
  - Dados:
    - `BUCKET: s3-bucket`
    - `PUBLIC_URL: http://localhost:8080`
  - Criado na aula anterior com `kubectl apply -f k8s/configmap.yaml`.
- **Objetivo**:
  - Remover variáveis hardcoded (`BUCKET` e `PUBLIC_URL`) do **Deployment** `widget-server`.
  - Configurar o **Deployment** para consumir o **ConfigMap** de forma escalável.
  - Demonstrar duas abordagens: referenciar chaves específicas (`configMapKeyRef`) e injetar todas as variáveis (`envFrom`).
- **Motivação**:
  - Evitar configurações manuais no **Deployment**, que não escalam e misturam responsabilidades.
  - Facilitar alterações centralizadas no **ConfigMap**, sem necessidade de modificar o **Deployment**.

## Integração do ConfigMap com o Deployment
### Abordagem 1: Referenciar Chaves Específicas (`configMapKeyRef`)
- **Atualização do `deployment.yaml`**:
  - As variáveis `BUCKET` e `PUBLIC_URL` são removidas (ou comentadas) da seção `env` do **Deployment**.
  - Novas entradas na seção `env` referenciam o **ConfigMap**:
  ```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: widget-server
    namespace: widget
  spec:
    replicas: 2
    selector:
      matchLabels:
        app: widget-server
    template:
      metadata:
        labels:
          app: widget-server
      spec:
        containers:
        - name: widget-server
          image: widget-server:latest
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "200m"
              memory: "256Mi"
          env:
          - name: CLOUDFLARE_BUCKET
            valueFrom:
              configMapKeyRef:
                name: widget-server-cm
                key: BUCKET
          - name: CLOUDFLARE_PUBLIC_URL
            valueFrom:
              configMapKeyRef:
                name: widget-server-cm
                key: PUBLIC_URL
  ```
  - **Detalhes**:
    - `env.name`: Define o nome da variável de ambiente na aplicação (ex.: `CLOUDFLARE_BUCKET`).
    - `valueFrom.configMapKeyRef`: Referencia uma chave específica do **ConfigMap**.
      - `name: widget-server-cm`: Nome do **ConfigMap**.
      - `key: BUCKET` ou `key: PUBLIC_URL`: Chave específica no `data` do **ConfigMap**.
    - A aplicação espera `CLOUDFLARE_BUCKET` e `CLOUDFLARE_PUBLIC_URL` (nomes homônimos às variáveis do `.env`), não `BUCKET` ou `PUBLIC_URL`, garantindo compatibilidade.
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/deployment.yaml`
    - Aplica o **Deployment** atualizado no namespace `widget`.
- **Verificação**:
  - **Comando**: `kubectl get pods -n widget`
    - Confirma que os pods estão subindo (ex.: `0/1` para `1/1` após a inicialização).
  - **Comando**: `kubectl logs <pod-name> -n widget`
    - Verifica os logs para confirmar que os pods iniciaram corretamente.
  - **Comando**: `kubectl describe pod <pod-name> -n widget`
    - Confirma que as variáveis de ambiente `CLOUDFLARE_BUCKET` e `CLOUDFLARE_PUBLIC_URL` estão sendo injetadas do **ConfigMap** `widget-server-cm`.
  - **Saída do `describe`**:
    - Mostra `Environment Variables` com:
      - `CLOUDFLARE_BUCKET` vindo de `widget-server-cm (BUCKET)`.
      - `CLOUDFLARE_PUBLIC_URL` vindo de `widget-server-cm (PUBLIC_URL)`.

### Abordagem 2: Injetar Todas as Variáveis (`envFrom`)
- **Problema com a Abordagem 1**:
  - Embora funcional, referenciar chaves específicas (`configMapKeyRef`) ainda exige manutenção manual no **Deployment** para cada nova variável adicionada ao **ConfigMap**.
  - Isso não é escalável, pois mudanças no **ConfigMap** exigem alterações no **Deployment**.
- **Solução: Usar `envFrom`**:
  - Injeta todas as chaves do **ConfigMap** como variáveis de ambiente automaticamente.
  - **Atualização do `deployment.yaml`**:
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: widget-server
      namespace: widget
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: widget-server
      template:
        metadata:
          labels:
            app: widget-server
        spec:
          containers:
          - name: widget-server
            image: widget-server:latest
            resources:
              requests:
                cpu: "100m"
                memory: "128Mi"
              limits:
                cpu: "200m"
                memory: "256Mi"
            envFrom:
            - configMapRef:
                name: widget-server-cm
    ```
  - **Detalhes**:
    - `envFrom.configMapRef.name: widget-server-cm`: Referencia o **ConfigMap** inteiro.
    - Todas as chaves do `data` do **ConfigMap** (ex.: `BUCKET`, `PUBLIC_URL`) são injetadas como variáveis de ambiente com nomes idênticos.
    - **Pré-requisito**: As chaves no **ConfigMap** (ex.: `BUCKET`, `PUBLIC_URL`) devem corresponder exatamente aos nomes esperados pela aplicação (ex.: `CLOUDFLARE_BUCKET`, `CLOUDFLARE_PUBLIC_URL`). Caso contrário, a aplicação não reconhecerá as variáveis.
    - **Solução para Nomenclatura**: Renomear as chaves no **ConfigMap** para corresponder às variáveis esperadas:
      ```yaml
      apiVersion: v1
      kind: ConfigMap
      metadata:
        name: widget-server-cm
        namespace: widget
      data:
        CLOUDFLARE_BUCKET: "s3-bucket"
        CLOUDFLARE_PUBLIC_URL: "http://localhost:8080"
      ```
      - **Nota**: Isso exige reaplicar o **ConfigMap** com `kubectl apply -f k8s/configmap.yaml`.
- **Vantagem**:
  - **Escalabilidade**: Novas variáveis adicionadas ao **ConfigMap** são injetadas automaticamente, sem alterar o **Deployment**.
  - **Simplicidade**: Elimina a necessidade de listar cada variável manualmente na seção `env`.
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/deployment.yaml`
    - Aplica o **Deployment** com `envFrom`.
  - **Verificação**:
    - **Comando**: `kubectl get pods -n widget`
      - Confirma que os pods estão subindo (ex.: `1/1` após a inicialização).
    - **Comando**: `kubectl describe pod <pod-name> -n widget`
      - Mostra que todas as variáveis do **ConfigMap** (`CLOUDFLARE_BUCKET`, `CLOUDFLARE_PUBLIC_URL`) foram injetadas como `Environment Variables` via `widget-server-cm (ConfigMap)`.
      - Exemplo de saída:
        ```
        Environment Variables from:
          widget-server-cm (ConfigMap)  Required
        ```
- **Observação**:
  - O campo `envFrom` é mais escalável, mas exige que as chaves do **ConfigMap** sejam idênticas aos nomes esperados pela aplicação.
  - Se as chaves do **ConfigMap** não corresponderem (ex.: `BUCKET` em vez de `CLOUDFLARE_BUCKET`), a aplicação não funcionará corretamente, como mencionado na aula.

## Teste e Validação
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/`
    - Aplica o **Deployment** atualizado (com `env` ou `envFrom`) e, se necessário, o **ConfigMap** com chaves renomeadas.
  - Resultado: Os pods reiniciam e atingem o estado `Running` (`1/1`) às 17:19 (horário mencionado na aula).
- **Verificação**:
  - **Comando**: `kubectl get pods -n widget`
    - Confirma que os pods estão ativos e funcionando.
  - **Comando**: `kubectl logs <pod-name> -n widget`
    - Verifica os logs para garantir que a aplicação iniciou sem erros.
  - **Comando**: `kubectl describe pod <pod-name> -n widget`
    - Confirma que as variáveis de ambiente estão corretamente configuradas:
      - Na abordagem `configMapKeyRef`, as variáveis específicas (`CLOUDFLARE_BUCKET`, `CLOUDFLARE_PUBLIC_URL`) são listadas.
      - Na abordagem `envFrom`, o **ConfigMap** inteiro é referenciado como origem das variáveis.
- **Resultado**:
  - A configuração foi bem-sucedida, com as variáveis sendo injetadas corretamente do **ConfigMap** `widget-server-cm`.
  - A abordagem `envFrom` é destacada como mais avançada e escalável, evitando a necessidade de atualizações manuais no **Deployment**.

## Boas Práticas
- **Nomenclatura**:
  - As chaves no **ConfigMap** devem corresponder exatamente aos nomes esperados pela aplicação (ex.: `CLOUDFLARE_BUCKET` em vez de `BUCKET`).
  - Usar nomes consistentes para recursos (ex.: `widget-server-cm`, `widget-server`, `widget-server-hpa`) para facilitar a manutenção.
- **Escalabilidade**:
  - Preferir `envFrom` para injetar todas as variáveis do **ConfigMap**, eliminando a necessidade de alterar o **Deployment** para cada nova variável.
  - Manter um **ConfigMap** por aplicação para organizar configurações específicas (ex.: `widget-server-cm` para `widget-server`).
- **Automação**:
  - Integrar a criação/atualização de **ConfigMaps** em pipelines de CI/CD, sincronizando com o arquivo `.env` da aplicação.
  - Exemplo: Um script na pipeline pode gerar o **ConfigMap** a partir do `.env` e aplicá-lo automaticamente.
- **Segurança**:
  - Evitar armazenar dados sensíveis (ex.: chaves de API, senhas) em **ConfigMap**; usar **Secrets** para esses casos.
  - Mesmo com `envFrom`, garantir que o **ConfigMap** contenha apenas dados não sensíveis.
- **Testes**:
  - Validar a injeção de variáveis em ambientes de desenvolvimento antes de aplicar em produção.
  - Usar `kubectl describe pod` para verificar as variáveis de ambiente injetadas.

## Planejamento para a Próxima Aula
- **Secrets**:
  - Criar um **Secret** para armazenar dados sensíveis (ex.: `CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`).
  - Configurar o **Deployment** para consumir o **Secret** como variáveis de ambiente ou arquivos montados.
  - Explicar codificação Base64, limitações de segurança (não criptografado por padrão), e opções como integração com **Vault** (mencionado como parte do módulo de secret management).
- **Outros Tópicos**:
  - Continuar refinando o **Ingress** para roteamento da aplicação.
  - Integrar ferramentas de observabilidade (ex.: Prometheus, Grafana) para monitorar métricas do **Deployment** e do **HPA**.
  - Realizar testes adicionais de carga para validar a aplicação com as novas configurações.
- **Vault**:
  - Revisitar conceitos de gerenciamento de segredos com **Vault**, explorando como ele pode ser integrado ao Kubernetes para gerenciar **Secrets** de forma segura.

## Limitações e Observações
- **Escalabilidade**:
  - A abordagem `configMapKeyRef` é funcional, mas menos escalável, exigindo atualizações manuais no **Deployment** para novas variáveis.
  - A abordagem `envFrom` é preferível, mas requer que as chaves do **ConfigMap** correspondam exatamente aos nomes esperados pela aplicação.
- **Nomenclatura**:
  - Erros de nomenclatura (ex.: `BUCKET` em vez de `CLOUDFLARE_BUCKET`) podem quebrar a aplicação, como destacado na aula.
  - Renomear chaves no **ConfigMap** (ex.: `CLOUDFLARE_BUCKET`, `CLOUDFLARE_PUBLIC_URL`) resolve o problema, mas exige reaplicação do **ConfigMap**.
- **Segurança**:
  - **ConfigMaps** não são adequados para dados sensíveis, reforçando a necessidade de **Secrets** na próxima aula.
  - Mesmo com `envFrom`, verificar que apenas dados não sensíveis estão no **ConfigMap**.
- **Ambiente Local**:
  - A aula usa um cluster local (provavelmente Minikube ou Kind) com **Metrics Server** configurado com `--kubelet-insecure-tls`, adequado para aprendizado, mas não para produção.
- **Automação**:
  - Para cenários reais, automatizar a criação de **ConfigMaps** a partir de arquivos `.env` em pipelines de CI/CD melhora a eficiência e reduz erros manuais.
- **Manutenção**:
  - Alterações no **ConfigMap** com `envFrom` não exigem mudanças no **Deployment**, mas podem requerer reinício dos pods (dependendo da estratégia de atualização, ex.: `RollingUpdate`).

## Conclusão
A aula demonstra como integrar o **ConfigMap** `widget-server-cm` ao **Deployment** `widget-server`, usando duas abordagens: `configMapKeyRef` (referenciar chaves específicas) e `envFrom` (injetar todas as variáveis). A abordagem `envFrom` é destacada como mais escalável, pois elimina a necessidade de atualizar o **Deployment** para novas variáveis, desde que as chaves do **ConfigMap** correspondam às esperadas pela aplicação (`CLOUDFLARE_BUCKET`, `CLOUDFLARE_PUBLIC_URL`). A aplicação foi validada com `kubectl get pods`, `kubectl logs`, e `kubectl describe pod`, confirmando a injeção correta das variáveis. A próxima aula abordará **Secrets** para dados sensíveis, integração com **Vault**, e refinamento da aplicação com observabilidade e testes.