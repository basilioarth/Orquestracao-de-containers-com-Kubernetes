# Resumo da Aula sobre Secrets no Kubernetes

## Introdução
A aula aborda a criação e integração de **Secrets** no Kubernetes, complementando o uso de **ConfigMap** abordado anteriormente. O foco é gerenciar dados sensíveis (ex.: `CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`) para a aplicação `widget-server`. A aula explica as limitações de segurança dos **Secrets** (codificação Base64, não criptografia), sua armazenagem no **etcd**, e a possibilidade de integração com ferramentas externas como **Vault**. Duas abordagens de integração com o **Deployment** são apresentadas: referenciar chaves específicas (`secretKeyRef`) e injetar todas as variáveis (`envFrom`). A aula reforça boas práticas e prepara para o encerramento do módulo com dicas de produtividade e ferramentas.

## Conceitos Fundamentais
- **Secrets**:
  - Um recurso nativo do Kubernetes (`apiVersion: v1`, `kind: Secret`) para armazenar dados sensíveis, como chaves de API, senhas ou credenciais.
  - Dados são codificados em **Base64**, não criptografados por padrão, o que não garante segurança robusta.
  - Armazenados no **etcd**, o banco de estado do Kubernetes, acessível por quem tem acesso ao cluster, a menos que protegido por **RBAC** ou criptografia adicional.
- **Limitações**:
  - **Base64** é apenas uma codificação, facilmente decodificável, não oferecendo segurança criptográfica.
  - Para maior segurança, é necessário:
    - Configurar **RBAC** para limitar acesso aos **Secrets**.
    - Habilitar criptografia no **etcd** (não abordado na aula).
    - Usar ferramentas externas como **Vault** para gerenciamento seguro de segredos.
- **Alternativas**:
  - **Vault** pode ser usado como um **sidecar** no **Deployment**, injetando segredos diretamente nos containers, evitando dependência direta do **Secret** do Kubernetes.
  - Outras estratégias de gerenciamento de segredos (mencionadas no módulo anterior) podem ser aplicadas, mas estão fora do escopo do Kubernetes nativo.
- **Sidecar**:
  - Um container auxiliar no mesmo pod que a aplicação, usado para tarefas como injeção de segredos (ex.: **Vault**) ou proxies (ex.: **Istio** para service mesh).
  - Não é comum rodar múltiplos containers de aplicação no mesmo pod, mas **sidecars** são úteis para funcionalidades complementares.

## Criação do Secret
- **Motivação**:
  - Armazenar dados sensíveis (`CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`) para a aplicação `widget-server`.
  - Manter configurações sensíveis separadas do **Deployment** e do **ConfigMap**, seguindo boas práticas de segurança.
- **Arquivo `secret.yaml`**:
  ```yaml
  apiVersion: v1
  kind: Secret
  metadata:
    name: widget-server-secret
    namespace: widget
  type: Opaque
  data:
    CLOUDFLARE_ACCESS_KEY_ID: I2==  # Base64 de "#"
    CLOUDFLARE_SECRET_ACCESS_KEY: I2==  # Base64 de "#"
    ACCOUNT_ID: I2==  # Base64 de "#"
  ```
  - **Detalhes**:
    - `apiVersion: v1`: Versão padrão para **Secret**.
    - `kind: Secret`: Define o tipo de recurso.
    - `metadata.name: widget-server-secret`: Nome do **Secret**, seguindo o padrão da aplicação (`widget-server`).
    - `metadata.namespace: widget`: Alinhado com o **Deployment** e **ConfigMap**.
    - `type: Opaque`: Tipo genérico para **Secrets** (outros tipos incluem `kubernetes.io/dockerconfigjson` para credenciais de registro, não abordado).
    - `data`: Contém pares chave-valor codificados em **Base64**.
      - `CLOUDFLARE_ACCESS_KEY_ID: I2==`: Codificação Base64 do valor `#`.
      - `CLOUDFLARE_SECRET_ACCESS_KEY: I2==`: Codificação Base64 do valor `#`.
      - `ACCOUNT_ID: I2==`: Codificação Base64 do valor `#`.
    - **Nota**: O valor `#` é usado como exemplo simplificado. Em cenários reais, cada chave teria um valor único codificado em Base64.
  - **Codificação Base64**:
    - O valor `#` codificado em Base64 é `I2==`.
    - Para codificar manualmente: `echo -n '#' | base64` (resulta em `I2==`).
    - Para decodificar: `echo -n 'I2==' | base64 -d` (retorna `#`).
    - **Importante**: A codificação deve ser feita manualmente ou via ferramentas antes de incluir no YAML, pois o Kubernetes não codifica automaticamente.
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/secret.yaml`
    - Cria o **Secret** no namespace `widget`.
- **Verificação**:
  - **Comando**: `kubectl get secret -n widget`
    - Lista os **Secrets**, confirmando a criação de `widget-server-secret` com 3 chaves.
  - **Comando**: `kubectl describe secret widget-server-secret -n widget`
    - Exibe detalhes, incluindo:
      - Namespace: `widget`
      - Type: `Opaque`
      - Data: 3 chaves (`CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`), todas codificadas em Base64.
  - **Nota**: Os valores não são exibidos em texto puro, apenas em Base64, para evitar exposição acidental.

## Integração do Secret com o Deployment
### Abordagem 1: Referenciar Chaves Específicas (`secretKeyRef`)
- **Atualização do `deployment.yaml`**:
  - Adiciona variáveis sensíveis na seção `env`, referenciando o **Secret**:
  ```yaml
  apiVersion: apps/v1
  kind: Deployment
  metadata:
    name: widget-server
    namespace: widget
  spec:
    replicas: 2
    selector:
      matchLabels:
        app: widget-server
    template:
      metadata:
        labels:
          app: widget-server
      spec:
        containers:
        - name: widget-server
          image: widget-server:latest
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "200m"
              memory: "256Mi"
          env:
          - name: CLOUDFLARE_ACCESS_KEY_ID
            valueFrom:
              secretKeyRef:
                name: widget-server-secret
                key: CLOUDFLARE_ACCESS_KEY_ID
          - name: CLOUDFLARE_SECRET_ACCESS_KEY
            valueFrom:
              secretKeyRef:
                name: widget-server-secret
                key: CLOUDFLARE_SECRET_ACCESS_KEY
          - name: ACCOUNT_ID
            valueFrom:
              secretKeyRef:
                name: widget-server-secret
                key: ACCOUNT_ID
  ```
  - **Detalhes**:
    - `env.name`: Nome da variável de ambiente esperada pela aplicação (ex.: `CLOUDFLARE_ACCESS_KEY_ID`).
    - `valueFrom.secretKeyRef`: Referencia uma chave específica do **Secret**.
      - `name: widget-server-secret`: Nome do **Secret**.
      - `key`: Chave no `data` do **Secret` (ex.: `CLOUDFLARE_ACCESS_KEY_ID`).
    - As chaves do **Secret** correspondem diretamente aos nomes esperados pela aplicação, garantindo compatibilidade.
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/deployment.yaml`
    - Aplica o **Deployment** atualizado.
- **Verificação**:
  - **Comando**: `kubectl get pods -n widget`
    - Confirma que os pods estão subindo (ex.: `0/1` para `1/1` após inicialização).
  - **Comando**: `kubectl logs <pod-name> -n widget`
    - Verifica os logs para garantir que a aplicação iniciou sem erros.
  - **Comando**: `kubectl describe pod <pod-name> -n widget`
    - Confirma que as variáveis de ambiente (`CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`) foram injetadas do **Secret** `widget-server-secret`.
    - Exemplo de saída:
      ```
      Environment:
        CLOUDFLARE_ACCESS_KEY_ID: <set to the key 'CLOUDFLARE_ACCESS_KEY_ID' in secret 'widget-server-secret'>
        CLOUDFLARE_SECRET_ACCESS_KEY: <set to the key 'CLOUDFLARE_SECRET_ACCESS_KEY' in secret 'widget-server-secret'>
        ACCOUNT_ID: <set to the key 'ACCOUNT_ID' in secret 'widget-server-secret'>
      ```

### Abordagem 2: Injetar Todas as Variáveis (`envFrom`)
- **Problema com a Abordagem 1**:
  - Referenciar chaves específicas (`secretKeyRef`) exige manutenção manual no **Deployment** para cada nova variável, o que não é escalável.
- **Solução: Usar `envFrom`**:
  - Injeta todas as chaves do **Secret** como variáveis de ambiente automaticamente.
  - **Atualização do `deployment.yaml`**:
    ```yaml
    apiVersion: apps/v1
    kind: Deployment
    metadata:
      name: widget-server
      namespace: widget
    spec:
      replicas: 2
      selector:
        matchLabels:
          app: widget-server
    template:
      metadata:
        labels:
          app: widget-server
      spec:
        containers:
        - name: widget-server
          image: widget-server:latest
          resources:
            requests:
              cpu: "100m"
              memory: "128Mi"
            limits:
              cpu: "200m"
              memory: "256Mi"
          envFrom:
          - configMapRef:
              name: widget-server-cm
          - secretRef:
              name: widget-server-secret
    ```
  - **Detalhes**:
    - `envFrom.secretRef.name: widget-server-secret`: Referencia o **Secret** inteiro.
    - Todas as chaves do `data` do **Secret** (`CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`) são injetadas como variáveis de ambiente com nomes idênticos.
    - Combina com o **ConfigMap** (`widget-server-cm`) na seção `envFrom`, injetando tanto variáveis não sensíveis quanto sensíveis.
    - **Pré-requisito**: As chaves do **Secret** devem corresponder exatamente aos nomes esperados pela aplicação (já garantido no exemplo).
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/deployment.yaml`
    - Aplica o **Deployment** com `envFrom` para **ConfigMap** e **Secret**.
- **Verificação**:
  - **Comando**: `kubectl get pods -n widget`
    - Confirma que os pods estão subindo (ex.: `1/1` após inicialização).
  - **Comando**: `kubectl logs <pod-name> -n widget`
    - Verifica os logs para garantir que a aplicação iniciou sem erros.
  - **Comando**: `kubectl describe pod <pod-name> -n widget`
    - Confirma que as variáveis de ambiente são injetadas de ambos os recursos:
      ```
      Environment Variables from:
        widget-server-cm (ConfigMap)  Required
        widget-server-secret (Secret)  Required
      ```
- **Vantagem**:
  - **Escalabilidade**: Novas chaves adicionadas ao **Secret** são injetadas automaticamente, sem alterar o **Deployment**.
  - **Simplicidade**: Combina **ConfigMap** e **Secret** em uma única seção `envFrom`, reduzindo configurações manuais.

## Teste e Validação
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/`
    - Aplica o **Deployment** atualizado (com `env` ou `envFrom`) e o **Secret**.
  - Resultado: Os pods reiniciam e atingem o estado `Running` (`1/1`).
- **Verificação**:
  - **Comando**: `kubectl get pods -n widget`
    - Confirma que os pods estão ativos.
  - **Comando**: `kubectl logs <pod-name> -n widget`
    - Verifica os logs para garantir que a aplicação iniciou corretamente.
  - **Comando**: `kubectl describe pod <pod-name> -n widget`
    - Confirma que as variáveis de ambiente (`CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`, `CLOUDFLARE_BUCKET`, `CLOUDFLARE_PUBLIC_URL`) foram injetadas corretamente do **Secret** e **ConfigMap**.
- **Resultado**:
  - A configuração foi bem-sucedida, com todas as variáveis injetadas corretamente.
  - A abordagem `envFrom` é destacada como mais escalável, permitindo a combinação de **ConfigMap** e **Secret** sem concorrência entre eles.

## Boas Práticas
- **Segurança**:
  - Sempre usar **Secrets** para dados sensíveis, nunca **ConfigMaps**.
  - Configurar **RBAC** para restringir acesso aos **Secrets** apenas à aplicação correspondente.
  - Considerar criptografia no **etcd** ou integração com **Vault** para maior segurança em produção.
- **Nomenclatura**:
  - As chaves no **Secret** devem corresponder exatamente aos nomes esperados pela aplicação (ex.: `CLOUDFLARE_ACCESS_KEY_ID`).
  - Usar nomes consistentes (ex.: `widget-server-secret`, `widget-server-cm`, `widget-server`) para alinhar recursos.
- **Escalabilidade**:
  - Preferir `envFrom` para injetar todas as chaves do **Secret** e **ConfigMap**, eliminando a necessidade de atualizar o **Deployment** para novas variáveis.
  - Manter um **Secret** e um **ConfigMap** por aplicação para organização.
- **Automação**:
  - Integrar a criação/atualização de **Secrets** em pipelines de CI/CD, gerando valores Base64 a partir de fontes seguras (ex.: variáveis de ambiente seguras no CI/CD).
  - Exemplo: Um script pode codificar valores em Base64 e criar o **Secret** automaticamente.
- **Testes**:
  - Validar a injeção de variáveis em ambientes de desenvolvimento antes de produção.
  - Usar `kubectl describe pod` para verificar as variáveis injetadas e `kubectl logs` para confirmar o comportamento da aplicação.
- **Sidecar com Vault**:
  - Para cenários avançados, considerar o uso de **Vault** como sidecar para injeção dinâmica de segredos, reduzindo a dependência do **Secret** nativo do Kubernetes.

## Planejamento para a Próxima Aula
- **Encerramento do Módulo**:
  - Revisar os conceitos abordados (ex.: **Deployment**, **HPA**, **ConfigMap**, **Secret**, **Ingress**).
  - Consolidar boas práticas para gerenciamento de aplicações no Kubernetes.
- **Produtividade**:
  - Apresentar ferramentas para facilitar o debugging e gerenciamento do cluster (ex.: interfaces gráficas, não detalhadas na aula).
  - Exemplos possíveis: **Lens**, **K9s**, ou dashboards como o **Kubernetes Dashboard**.
- **Outros Tópicos**:
  - Continuar refinando o **Ingress** para roteamento da aplicação.
  - Integrar observabilidade (ex.: **Prometheus**, **Grafana**) para monitorar métricas do **Deployment** e **HPA**.
  - Realizar testes adicionais de carga para validar a aplicação com as configurações atuais.

## Limitações e Observações
- **Segurança**:
  - **Secrets** do Kubernetes não são criptografados por padrão, apenas codificados em Base64, exigindo cuidados adicionais (ex.: **RBAC**, criptografia no **etcd**, ou **Vault**).
  - Acesso ao **etcd** pode expor os **Secrets** se não houver restrições adequadas.
- **Escalabilidade**:
  - A abordagem `secretKeyRef` é menos escalável, exigindo atualizações manuais no **Deployment** para novas variáveis.
  - A abordagem `envFrom` é preferível, mas requer que as chaves do **Secret** correspondam aos nomes esperados pela aplicação.
- **Nomenclatura**:
  - Erros de nomenclatura (ex.: chaves do **Secret** diferentes do `.env`) podem quebrar a aplicação, como já visto com **ConfigMap**.
- **Ambiente Local**:
  - A aula usa um cluster local (provavelmente **Minikube** ou **Kind**) com **Metrics Server** configurado com `--kubelet-insecure-tls`, adequado para aprendizado, mas não para produção.
- **Sidecar**:
  - O uso de **Vault** como sidecar é mencionado como uma alternativa avançada, mas fora do escopo da aula, sendo uma recomendação para exploração futura.
- **Manutenção**:
  - Alterações no **Secret** com `envFrom` não exigem mudanças no **Deployment**, mas podem requerer reinício dos pods (dependendo da estratégia de atualização, ex.: `RollingUpdate`).

## Conclusão
A aula demonstra a criação e integração de um **Secret** (`widget-server-secret`) para gerenciar dados sensíveis (`CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`) no **Deployment** `widget-server`. Duas abordagens são apresentadas: `secretKeyRef` (chaves específicas) e `envFrom` (todas as chaves), com a última sendo mais escalável. O **Secret** é codificado em Base64 e armazenado no **etcd**, com limitações de segurança destacadas. A integração com o **ConfigMap** (`widget-server-cm`) é mantida, permitindo a injeção de variáveis sensíveis e não sensíveis. A validação com `kubectl get pods`, `kubectl logs`, e `kubectl describe pod` confirma o sucesso da configuração. A próxima aula encerrará o módulo, revisando conceitos e apresentando ferramentas para produtividade.