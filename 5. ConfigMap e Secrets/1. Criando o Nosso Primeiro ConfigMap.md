# Resumo da Aula sobre ConfigMap no Kubernetes

## Introdução
A aula introduz os conceitos de **ConfigMap** e **Secrets** no Kubernetes, com foco inicial no **ConfigMap**. Esses recursos permitem gerenciar configurações e dados sensíveis de forma separada do **Deployment**, promovendo escalabilidade e boas práticas. A aula explica a diferença entre informações sensíveis e não sensíveis, cria um **ConfigMap** para a aplicação `widget-server`, e demonstra como ele pode ser usado para armazenar variáveis de ambiente não sensíveis. A integração com o **Deployment** é mencionada, mas será detalhada na próxima aula.

## Conceitos Fundamentais
- **ConfigMap**:
  - Um recurso do Kubernetes (`apiVersion: v1`, `kind: ConfigMap`) usado para armazenar dados de configuração não sensíveis, como variáveis de ambiente ou arquivos de configuração.
  - Ideal para informações como endpoints de API (ex.: URLs de staging/produção) que não requerem sigilo.
  - Permite separar configurações do código da aplicação, facilitando manutenção e escalabilidade.
- **Secrets**:
  - Usado para dados sensíveis, como senhas, chaves de API, ou credenciais (ex.: `AccessKeyID`, `SecretAccessKey`).
  - Não devem ser armazenados em **ConfigMap** para evitar exposição.
  - Será abordado em detalhes na próxima aula.
- **Exemplo de Variáveis**:
  - **Não sensíveis** (adequadas para **ConfigMap**):
    - `BUCKET`: Nome do bucket (depende do caso, pode ser público).
    - `PUBLIC_URL`: URL pública, como `http://localhost:8080` (não sensível por definição).
  - **Sensíveis** (adequadas para **Secrets**):
    - `CLOUDFLARE_ACCESS_KEY_ID`: Chave de acesso.
    - `CLOUDFLARE_SECRET_ACCESS_KEY`: Chave secreta.
    - `ACCOUNT_ID`: Identificador de conta (geralmente sensível).
- **Boas Práticas**:
  - Evitar embutir configurações diretamente no **Deployment** (não escalável, mistura responsabilidades).
  - Usar **ConfigMap** para referenciar configurações, permitindo alterações sem modificar o **Deployment**.

## Criação do ConfigMap
- **Motivação**:
  - Armazenar variáveis não sensíveis (`BUCKET` e `PUBLIC_URL`) para a aplicação `widget-server`.
  - Facilitar a manutenção, permitindo alterações centralizadas no **ConfigMap** sem tocar no **Deployment**.
- **Arquivo `configmap.yaml`**:
  ```yaml
  apiVersion: v1
  kind: ConfigMap
  metadata:
    name: widget-server-cm
    namespace: widget
  data:
    BUCKET: "s3-bucket"
    PUBLIC_URL: "http://localhost:8080"
  ```
  - **Detalhes**:
    - `apiVersion: v1`: Versão padrão para **ConfigMap**.
    - `kind: ConfigMap`: Define o tipo de recurso.
    - `metadata.name: widget-server-cm`: Nome do **ConfigMap**, seguindo o padrão de nomenclatura da aplicação (`widget-server`).
    - `metadata.namespace: widget`: Define o namespace, alinhado com o **Deployment** e o **HPA**.
    - `data`: Contém pares chave-valor para as variáveis:
      - `BUCKET: "s3-bucket"`: Nome fictício do bucket.
      - `PUBLIC_URL: "http://localhost:8080"`: URL pública usada para testes.
  - **Nota**:
    - O campo `data` aceita strings simples (como no exemplo) ou arquivos de configuração (não abordado aqui).
    - O bucket foi considerado não sensível para o exemplo, mas em cenários reais pode requerer um **Secret** se for privado.
- **Aplicação**:
  - **Comando**: `kubectl apply -f k8s/configmap.yaml`
    - Cria o **ConfigMap** no cluster, no namespace `widget`.
- **Verificação**:
  - **Comando**: `kubectl get configmap -n widget`
    - Lista os **ConfigMaps** no namespace `widget`, confirmando a criação de `widget-server-cm` com 2 chaves (`BUCKET` e `PUBLIC_URL`).
  - **Comando**: `kubectl describe configmap widget-server-cm -n widget`
    - Exibe detalhes, incluindo:
      - Namespace: `widget`.
      - Data:
        - `BUCKET: s3-bucket`
        - `PUBLIC_URL: http://localhost:8080`
  - **Abreviação**: `kubectl get cm -n widget` funciona como atalho para `configmap`.

## Integração com o Deployment
- **Objetivo**:
  - Configurar o **Deployment** `widget-server` para consumir as variáveis do **ConfigMap** como variáveis de ambiente (`env`).
  - Isso permite que a aplicação acesse `BUCKET` e `PUBLIC_URL` sem hardcoding no manifesto.
- **Como Fazer**:
  - Usar a seção `env` no `spec.template.spec.containers` do **Deployment** para referenciar o **ConfigMap**.
  - Exemplo genérico (não implementado na aula, será detalhado na próxima):
    ```yaml
    spec:
      containers:
      - name: widget-server
        image: widget-server:latest
        env:
        - name: BUCKET
          valueFrom:
            configMapKeyRef:
              name: widget-server-cm
              key: BUCKET
        - name: PUBLIC_URL
          valueFrom:
            configMapKeyRef:
              name: widget-server-cm
              key: PUBLIC_URL
    ```
  - **Explicação**:
    - `env.name`: Nome da variável de ambiente na aplicação.
    - `valueFrom.configMapKeyRef`: Referencia uma chave específica do **ConfigMap**.
    - `name: widget-server-cm`: Nome do **ConfigMap**.
    - `key`: Chave dentro do `data` do **ConfigMap** (ex.: `BUCKET` ou `PUBLIC_URL`).
- **Vantagem**:
  - Alterações no **ConfigMap** (ex.: mudar `PUBLIC_URL`) são refletidas na aplicação sem necessidade de reaplicar o **Deployment** (dependendo da estratégia de atualização).
  - Separação de responsabilidades: o **Deployment** foca na lógica do pod, enquanto o **ConfigMap** gerencia configurações.

## Planejamento para a Próxima Aula
- **Integração do ConfigMap**:
  - Atualizar o **Deployment** `widget-server` para consumir as variáveis do **ConfigMap** `widget-server-cm`.
  - Testar a aplicação para confirmar que `BUCKET` e `PUBLIC_URL` são injetados corretamente.
- **Secrets**:
  - Criar um **Secret** para armazenar dados sensíveis (ex.: `CLOUDFLARE_ACCESS_KEY_ID`, `CLOUDFLARE_SECRET_ACCESS_KEY`, `ACCOUNT_ID`).
  - Configurar o **Deployment** para consumir o **Secret** como variáveis de ambiente ou arquivos montados.
  - Discutir codificação Base64, opções de criptografia, e boas práticas de segurança.
- **Outros Tópicos**:
  - Continuar refinando o **Ingress** para roteamento da aplicação.
  - Integrar observabilidade (ex.: Prometheus, Grafana) para monitorar métricas do **Deployment** e do **HPA**.
  - Realizar testes adicionais de carga para validar configurações sob diferentes condições.

## Limitações e Observações
- **ConfigMap**:
  - Ideal para dados não sensíveis, mas pode ser ineficiente para configurações grandes (ex.: arquivos de configuração complexos), onde volumes montados são mais apropriados.
  - Limite de tamanho: 1MiB por **ConfigMap** (suficiente para a maioria dos casos).
- **Secrets**:
  - Dados sensíveis devem ser armazenados em **Secrets**, que são codificados em Base64 (não criptografados por padrão, exigindo cuidados adicionais em produção).
  - Integração com gerenciadores de segredos (ex.: Vault) pode ser necessária para cenários avançados.
- **Boas Práticas**:
  - Usar **ConfigMap** para configurações reutilizáveis e não sensíveis, como URLs ou parâmetros de aplicação.
  - Evitar embutir configurações no **Deployment** para facilitar manutenção e versionamento.
  - Definir nomes consistentes (ex.: `widget-server-cm`) para alinhar com outros recursos (`widget-server`, `widget-server-hpa`).
  - Testar a injeção de variáveis em ambientes de desenvolvimento antes de produção.
- **Ambiente Local**:
  - A aula usa um cluster local (provavelmente Minikube ou Kind), com **Metrics Server** configurado com `--kubelet-insecure-tls` (aceitável para aprendizado, mas não para produção).
- **Escalabilidade**:
  - Separar configurações em **ConfigMap** e **Secrets** melhora a escalabilidade, pois alterações não exigem recriação de pods (dependendo da estratégia de atualização do **Deployment**).
  - Para mudanças frequentes, considerar ferramentas de CI/CD para gerenciar **ConfigMaps** e **Secrets**.

## Conclusão
A aula apresenta o **ConfigMap** como uma solução para gerenciar configurações não sensíveis no Kubernetes, criando o `widget-server-cm` com as variáveis `BUCKET` e `PUBLIC_URL` no namespace `widget`. O recurso foi aplicado e verificado com `kubectl get` e `kubectl describe`, confirmando a criação bem-sucedida. A integração com o **Deployment** foi mencionada, mas será detalhada na próxima aula, junto com a criação de **Secrets** para dados sensíveis. A abordagem reforça a separação de responsabilidades, facilitando a manutenção e escalabilidade da aplicação `widget-server`. A próxima aula continuará com a injeção de variáveis, configuração de **Secrets**, e refinamento da aplicação com observabilidade e testes.