# Resumo da Aula sobre Configuração de Recursos no Pod e Limitações do Objeto Pod no Kubernetes

## Introdução
A aula foca na configuração de **recursos** (CPU e memória) no arquivo `pod.yaml` para o pod `widget-server`, resolvendo o problema de falta de limites de recursos identificado anteriormente. A prática de definir `requests` e `limits` é apresentada como essencial para evitar a disputa de recursos no nó. A aula também explora a política de **pull** de imagens (`imagePullPolicy`) e destaca as limitações do objeto **Pod** para cenários de produção, como a ausência de controladores para réplicas e resiliência. A introdução de objetos mais avançados, como **ReplicaSet** e **Deployment**, é preparada para a próxima aula.

## Configuração de Recursos no Pod
- **Contexto do Problema**:
  - O pod `widget-server` não especificava limites de recursos, permitindo que consumisse toda a CPU e memória do nó (`worker2`), o que é uma má prática em ambientes com múltiplos pods.
  - O Kubernetes exibia um aviso no `kubectl describe pod` sobre a ausência de `resources`, reforçando a necessidade de configuração.
- **Solução: Definir `requests` e `limits`**:
  - Os recursos são configurados na seção `spec.containers.resources` do arquivo `pod.yaml`.
  - **Arquivo `pod.yaml` atualizado**:
    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: widget-server
      namespace: widget
    spec:
      containers:
      - name: widget-server
        image: danielrodrigues/widget-server:v3
        ports:
        - containerPort: 3333
        env:
        - name: SECRET_ACCESS
          value: "#<secret_access_value>"
        - name: BUCKET
          value: "#<bucket_value>"
        - name: ACCOUNT_ID
          value: "#<account_id_value>"
        - name: PUBLIC_URL
          value: "#<public_url_value>"
        - name: LOCALHOST
          value: "http://localhost:3333"
        resources:
          requests:
            cpu: "200m"
            memory: "256Mi"
          limits:
            cpu: "300m"
            memory: "384Mi"
    ```
  - **Explicação**:
    - **`requests`**:
      - Define o **mínimo** de recursos garantidos para o pod.
      - `cpu: "200m"`: 200 millicores (m), equivalente a 0,2 vCPU (1 vCPU = 1000m). Como o nó tem 4 vCPUs (4000m), sobram 3800m para outros pods.
      - `memory: "256Mi"`: 256 MB de memória RAM.
    - **`limits`**:
      - Define o **máximo** de recursos que o pod pode consumir.
      - `cpu: "300m"`: 300 millicores, permitindo uma "gordura" de 100m acima do request.
      - `memory: "384Mi"`: 384 MB, com 128 MB adicionais acima do request.
    - Essa configuração garante que o pod tenha recursos suficientes, mas evita monopolizar o nó, mesmo em picos de uso.
- **Aplicação e Validação**:
  - **Comando `kubectl delete -f k8s/pod.yaml`**:
    - Deleta o pod existente, necessário porque alterações em `resources` não são aplicadas dinamicamente.
    - Observação: Deletar e recriar pods manualmente não é recomendado em produção ou staging, mas é aceitável para testes.
  - **Comando `kubectl apply -f k8s/pod.yaml`**:
    - Reaplica o `pod.yaml` com a configuração de recursos.
  - **Comando `kubectl get pods -n widget`**:
    - Confirma que o pod `widget-server` está no estado **Running**.
  - **Comando `kubectl describe pod widget-server -n widget`**:
    - Mostra que a imagem `v3` já estava presente no nó (`already present on machine`), resultando em um deploy rápido.
    - Confirma que os recursos (`requests` e `limits`) foram aplicados corretamente, sem mais avisos sobre ausência de configuração.

## Política de Pull de Imagens
- **Conceito de `imagePullPolicy`**:
  - Define como o Kubernetes lida com o download da imagem do contêiner.
  - Opções disponíveis:
    - **`IfNotPresent`** (padrão): Baixa a imagem apenas se ela não estiver presente no nó.
    - **`Always`**: Baixa a imagem sempre, mesmo que já esteja presente.
    - **`Never`**: Não baixa a imagem, assumindo que ela já está no nó (útil em cenários offline, mas arriscado).
  - No `pod.yaml`, pode ser especificado em `spec.containers.imagePullPolicy`. Se omitido, o padrão é `IfNotPresent`.
- **Teste com `Always`**:
  - Para demonstrar, o `pod.yaml` foi temporariamente alterado para incluir:
    ```yaml
    spec:
      containers:
      - name: widget-server
        image: danielrodrigues/widget-server:v3
        imagePullPolicy: Always
        ...
    ```
  - **Comandos Executados**:
    - `kubectl delete -f k8s/pod.yaml`: Deleta o pod existente.
    - `kubectl apply -f k8s/pod.yaml`: Reaplica com `imagePullPolicy: Always`.
    - `kubectl describe pod widget-server -n widget`: Mostra que o Kubernetes fez o **pull** da imagem `v3`, mesmo estando presente, confirmando o comportamento de `Always`.
  - **Observação**:
    - Usar `Always` é útil para testes, mas pode aumentar a latência de deploy e sobrecarregar repositórios de imagens em produção.
    - A boa prática é manter `IfNotPresent` (ou omitir) e garantir **imutabilidade de tags**, criando uma nova tag (ex.: `v4`) para cada alteração na aplicação.
  - Após o teste, o `imagePullPolicy: Always` foi removido do `pod.yaml`, e o pod foi recriado com `kubectl apply`, voltando ao padrão `IfNotPresent`.

## Limitações do Objeto Pod
- **Mecanismo de Self-Healing**:
  - O Kubernetes detecta falhas no pod (ex.: crash devido a erros de validação ou dependências) e aplica um **restart** automático, demonstrando o mecanismo de **self-healing**.
  - Exemplo: Erros anteriores (Zod, AWS SDK, New Relic) fizeram o pod entrar em **CrashLoopBackOff**, mas o Kubernetes tentou reiniciá-lo.
  - **Limitação**: O restart nem sempre resolve o problema (ex.: configurações ausentes), exigindo intervenção manual e um bom sistema de **observabilidade** (logs, métricas).
- **Ausência de Controladores**:
  - Ao deletar o pod com `kubectl delete pod widget-server -n widget`:
    - O pod é removido permanentemente, e o `kubectl get pods -n widget` mostra que não há mais pods no namespace.
    - Não há um controlador para recriar o pod automaticamente, ao contrário do que ocorre em cenários com múltiplas instâncias no AWS ECS.
  - **Problema**: O objeto **Pod** sozinho não suporta:
    - **Réplicas**: Executar múltiplas instâncias da aplicação para alta disponibilidade.
    - **Resiliência**: Recriar automaticamente pods deletados ou que falharam permanentemente.
  - **Antipadrão**: Criar múltiplos pods manualmente (ex.: `widget-server-1`, `widget-server-2`) duplicando o YAML é inviável e não escalável.
- **Natureza do Pod**:
  - O pod é a **menor unidade** do Kubernetes, projetado para ser **descartável** e **cíclico**.
  - Não é adequado para rodar aplicações em produção diretamente, pois não oferece mecanismos de controle para gerenciar instâncias ou atualizações.

## Necessidade de Objetos Superiores
- **Introdução a ReplicaSet e Deployment**:
  - Para superar as limitações do pod, são necessários objetos com **superpoderes**:
    - **ReplicaSet**: Garante um número definido de réplicas de um pod, recriando-os se forem deletados ou falharem.
    - **Deployment**: Gerencia ReplicaSets, permitindo atualizações contínuas (ex.: rolling updates), escalabilidade e reversão.
  - Esses objetos serão explorados na próxima aula, substituindo a criação manual de pods em produção.
- **Por que Pod Não é Suficiente?**:
  - Um pod sozinho não atende a cenários reais, como:
    - Manter múltiplas instâncias para balanceamento de carga, como no AWS ECS.
    - Garantir alta disponibilidade e resiliência contra falhas.
    - Facilitar atualizações de aplicação sem downtime.
  - A aula usa o pod para fins educacionais, mas reconhece que, em produção, **Deployments** são a prática padrão.

## Conclusão
A aula configura **recursos** (`requests` e `limits`) no `pod.yaml` para o pod `widget-server`, garantindo que ele consuma apenas uma fração dos recursos do nó (200-300m de CPU e 256-384Mi de memória). A política de **pull** de imagens é explorada, com testes usando `imagePullPolicy: Always` e a recomendação de manter `IfNotPresent` com tags imutáveis. As limitações do objeto **Pod** são destacadas, como a falta de controladores para réplicas e resiliência, comprovada ao deletar o pod sem recriação automática. A aula prepara o terreno para a introdução de **ReplicaSet** e **Deployment**, que oferecerão soluções para escalabilidade, alta disponibilidade e atualizações, substituindo o uso direto de pods em produção.