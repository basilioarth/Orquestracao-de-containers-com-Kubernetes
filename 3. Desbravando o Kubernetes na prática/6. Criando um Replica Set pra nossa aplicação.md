# Resumo da Aula sobre Configuração de ReplicaSet no Kubernetes e Limitações para Atualizações

## Introdução
A aula introduz o conceito de **ReplicaSet**, um controlador do Kubernetes que gerencia múltiplas réplicas de um pod, superando a limitação do objeto **Pod** em não suportar réplicas ou recriação automática. O arquivo `pod.yaml` é convertido para um `replica-set.yaml`, configurando cinco réplicas do pod `widget-server`. A aula demonstra como o ReplicaSet mantém o número desejado de pods, mas destaca suas limitações em gerenciar atualizações de versão, como a troca de imagem (`v3` para `v2`), que resulta em falhas sem eventos de atualização. Isso prepara o terreno para a introdução do objeto **Deployment** na próxima aula, que resolve problemas de versionamento e atualizações sem downtime.

## Configuração do ReplicaSet
- **Contexto**:
  - O objeto **Pod** não suporta réplicas ou resiliência contra deleções, conforme visto na aula anterior. O **ReplicaSet** é apresentado como um controlador que garante um número definido de réplicas em execução.
  - O arquivo `pod.yaml` é renomeado para `replica-set.yaml` e modificado para criar um **ReplicaSet** em vez de um pod único.
- **Modificações no Arquivo YAML**:
  - **Arquivo `replica-set.yaml`**:
    ```yaml
    apiVersion: apps/v1
    kind: ReplicaSet
    metadata:
      name: widget-server-rs
      namespace: widget
    spec:
      replicas: 5
      selector:
        matchLabels:
          app: widget-server
      template:
        metadata:
          labels:
            app: widget-server
        spec:
          containers:
          - name: widget-server
            image: danielrodrigues/widget-server:v3
            ports:
            - containerPort: 3333
            env:
            - name: SECRET_ACCESS
              value: "#<secret_access_value>"
            - name: BUCKET
              value: "#<bucket_value>"
            - name: ACCOUNT_ID
              value: "#<account_id_value>"
            - name: PUBLIC_URL
              value: "#<public_url_value>"
            - name: LOCALHOST
              value: "http://localhost:3333"
            resources:
              requests:
                cpu: "200m"
                memory: "256Mi"
              limits:
                cpu: "300m"
                memory: "384Mi"
    ```
  - **Mudanças Realizadas**:
    - **`apiVersion`**: Alterado de `v1` para `apps/v1`, pois o ReplicaSet pertence à API de aplicativos do Kubernetes.
    - **`kind`**: Alterado de `Pod` para `ReplicaSet`.
    - **`metadata.name`**: Renomeado para `widget-server-rs` para refletir que é um ReplicaSet.
    - **`spec.replicas`**: Adicionado para especificar o número desejado de réplicas (5).
    - **`spec.selector.matchLabels`**: Define um seletor que associa o ReplicaSet aos pods com a label `app: widget-server`.
    - **`spec.template`**: Inclui a especificação do pod (metadados e contêineres), idêntica à do `pod.yaml`, mas agora encapsulada como um modelo para os pods gerados.
    - **`template.metadata.labels`**: Adiciona a label `app: widget-server` para que o seletor do ReplicaSet possa identificar os pods gerenciados.
    - O restante (contêineres, portas, variáveis de ambiente, recursos) permanece igual ao `pod.yaml`.
- **Funcionamento do ReplicaSet**:
  - O ReplicaSet usa o campo `selector.matchLabels` para localizar pods com a label `app: widget-server`.
  - Ele verifica se o número de pods em execução corresponde ao valor de `replicas` (5). Se houver menos (ex.: 4), cria novos pods; se houver mais, deleta os excedentes.
  - Cada pod gerado tem um nome aleatório baseado no nome do ReplicaSet (ex.: `widget-server-rs-8nspr`, `widget-server-rs-9pws8`), com sufixos únicos.
- **Aplicação e Validação**:
  - **Comando `kubectl delete -f k8s/pod.yaml`**:
    - Confirma que o pod anterior foi deletado, garantindo que não há recursos conflitantes.
  - **Comando `kubectl apply -f k8s/replica-set.yaml`**:
    - Cria o ReplicaSet `widget-server-rs` no namespace `widget`.
  - **Comando `kubectl get rs -n widget`**:
    - Mostra o ReplicaSet com 5 réplicas desejadas, 5 em execução e 5 prontas (`DESIRED: 5, CURRENT: 5, READY: 5`).
  - **Comando `kubectl get pods -n widget`**:
    - Lista os cinco pods criados pelo ReplicaSet, cada um com um nome único (ex.: `widget-server-rs-8nspr`).
  - **Teste de Resiliência**:
    - **Comando `kubectl delete pod widget-server-rs-8nspr -n widget`**:
      - Deleta um pod específico.
      - O ReplicaSet detecta que apenas 4 pods estão em execução (abaixo das 5 desejadas) e cria um novo pod automaticamente para manter a consistência.
    - **Comando `kubectl get pods -n widget`**:
      - Confirma que o número de pods voltou a 5, demonstrando o mecanismo de **self-healing** do ReplicaSet.
  - **Escalamento**:
    - Alterando `replicas: 15` no `replica-set.yaml` e aplicando com `kubectl apply`:
      - O ReplicaSet cria 10 novos pods, totalizando 15.
    - Revertendo para `replicas: 5`:
      - O ReplicaSet deleta 10 pods, mantendo apenas 5, mostrando controle dinâmico do número de réplicas.
- **Recursos por Pod**:
  - Cada pod consome os recursos definidos (`200m` a `300m` de CPU, `256Mi` a `384Mi` de memória).
  - Com 5 réplicas, o consumo total é 1000m-1500m de CPU e 1280Mi-1920Mi de memória. Com 15 réplicas, seria 3000m-4500m de CPU, quase metade dos 4000m disponíveis no nó, destacando a importância de monitorar recursos.

## Limitações do ReplicaSet
- **Problema de Rede**:
  - Cada pod gerado pelo ReplicaSet tem um IP único (ex.: `10.244.2.7`, `10.244.1.7`), que é interno ao cluster e não fixo.
  - O comando `kubectl port-forward` só pode ser usado em um pod específico, o que não é prático para múltiplas réplicas.
  - Para clientes acessarem a aplicação, expor múltiplos IPs variáveis é inviável, indicando a necessidade de um objeto como **Service** para balanceamento de carga (a ser abordado em aulas futuras).
- **Problema de Atualização de Versão**:
  - Teste: Alterar a imagem no `replica-set.yaml` de `danielrodrigues/widget-server:v3` para `v2` e aplicar com `kubectl apply`.
    - **Resultado**: O ReplicaSet não atualiza os pods para a nova versão (`v2`). O `kubectl describe pod` não mostra eventos de atualização, e os pods continuam usando `v3`.
  - **Motivo**: O ReplicaSet controla apenas o número de réplicas, não gerencia mudanças de versão ou atualizações de imagem. Ele não suporta estratégias de atualização (ex.: rolling update).
  - **Solução Manual**: Deletar o ReplicaSet (`kubectl delete rs widget-server-rs -n widget`) e reaplicar o YAML com a nova versão.
    - **Problema**: Isso causa **downtime**, pois todos os pods são deletados antes de recriar com a nova versão, o que não é aceitável em produção.
- **Conclusão**: O ReplicaSet é eficaz para manter réplicas, mas não resolve o problema de atualizações de versão sem interrupção, exigindo um objeto superior como o **Deployment**.

## Comparação com o Passado
- **Replication Controller (RC)**:
  - No passado, o Kubernetes usava o **Replication Controller**, um conceito obsoleto substituído pelo **ReplicaSet**.
  - Se um cluster ainda usa RC, ele está desatualizado e precisa de atualização urgente.
  - O ReplicaSet é a implementação moderna, oficial nas versões atuais do Kubernetes.

## Observações e Boas Práticas
- **ImagePullPolicy**:
  - Com múltiplas réplicas, o uso de `imagePullPolicy: Always` é ineficiente, pois cada pod faria um pull da imagem, aumentando a latência e sobrecarga no repositório (ex.: 15 pulls para 15 réplicas).
  - A prática recomendada é `IfNotPresent`, reutilizando a imagem já presente no nó, especialmente com tags imutáveis.
- **Controle de Recursos**:
  - O ReplicaSet não gerencia recursos no nível do controlador, mas sim no nível de cada pod. É crucial dimensionar `replicas` considerando a capacidade do nó (ex.: 15 réplicas consomem quase metade da CPU do nó).
- **Uso do ReplicaSet**:
  - Embora o ReplicaSet seja mais poderoso que o **Pod**, ele raramente é usado diretamente em produção. Em vez disso, é gerenciado por um **Deployment**, que adiciona funcionalidades de atualização e reversão.
- **Abreviações no kubectl**:
  - Para verificar ReplicaSets: `kubectl get rs -n widget` (abreviação de `replicaSet`).

## Próximos Passos
- **Objeto Deployment**:
  - A próxima aula abordará o **Deployment**, que gerencia ReplicaSets e suporta atualizações sem downtime (ex.: rolling updates), resolvendo o problema de versionamento identificado.
- **Exposição de Rede**:
  - Resolver o problema de acesso a múltiplos pods com IPs variáveis, provavelmente com o uso de um **Service** para balanceamento de carga.
- **Evitar Downtime**:
  - Explorar estratégias para atualizar versões da aplicação sem interrupção, um recurso nativo do **Deployment**.

## Conclusão
A aula converte o `pod.yaml` em um `replica-set.yaml`, configurando um **ReplicaSet** para gerenciar cinco réplicas do pod `widget-server`. O controlador mantém o número desejado de pods, recriando-os automaticamente em caso de deleção, demonstrando resiliência. No entanto, o ReplicaSet não suporta atualizações de versão (ex.: troca de `v3` para `v2`), exigindo deleção manual e causando downtime, o que é uma limitação crítica. A aula destaca a importância de gerenciar recursos por pod e manter `imagePullPolicy: IfNotPresent`. A introdução do **Deployment** é preparada para a próxima aula, prometendo resolver problemas de atualização e exposição de rede, consolidando a hierarquia de objetos do Kubernetes.