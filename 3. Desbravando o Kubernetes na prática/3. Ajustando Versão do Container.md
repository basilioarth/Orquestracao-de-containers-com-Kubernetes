# Resumo da Aula sobre Configuração de Variáveis de Ambiente e Execução do Pod no Kubernetes

## Introdução
A aula dá continuidade à execução da aplicação **Widget Server** no cluster Kubernetes configurado com o **Kind**, focando na resolução do erro **CrashLoopBackOff** identificado anteriormente. O problema é causado pela ausência de variáveis de ambiente necessárias para a aplicação, validadas pelo **Zod**. A solução é implementada adicionando essas variáveis ao arquivo `pod.yaml` de forma declarativa, e a aula valida a execução do pod, explorando o mecanismo de **self-healing** do Kubernetes e o comando `kubectl port-forward` para acessar a aplicação. Um erro de rota (`/health`) é identificado, mas será investigado na próxima aula.

## Resolução do Erro CrashLoopBackOff
- **Contexto do Problema**:
  - O pod `widget-server` no namespace `widget` estava em estado **CrashLoopBackOff** devido à falta de variáveis de ambiente requeridas pela aplicação (validadas pelo Zod).
  - Essas variáveis foram definidas anteriormente no contexto do AWS ECS e são necessárias para integração com o **Cloudflare** (ex.: `SECRET_ACCESS`, `BUCKET`, `ACCOUNT_ID`, `PUBLIC_URL`).
- **Solução Simples (Variáveis de Ambiente no YAML)**:
  - Em vez de usar um **ConfigMap** (que será explorado posteriormente), as variáveis são adicionadas diretamente ao `pod.yaml` na seção `spec.containers.env` por simplicidade, já que a aula foca em um ambiente de teste com baixa confidencialidade.
  - **Arquivo `pod.yaml` atualizado**:
    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: widget-server
      namespace: widget
    spec:
      containers:
      - name: widget-server
        image: danielrodrigues/widget-server:D49E8862
        ports:
        - containerPort: 3333
        env:
        - name: SECRET_ACCESS
          value: "#<secret_access_value>"
        - name: BUCKET
          value: "#<bucket_value>"
        - name: ACCOUNT_ID
          value: "#<account_id_value>"
        - name: PUBLIC_URL
          value: "#<public_url_value>"
        - name: LOCALHOST
          value: "http://localhost:3333"
    ```
  - **Explicação**:
    - `spec.containers.env`: Lista as variáveis de ambiente no formato chave-valor.
    - Cada variável é definida com `name` (nome da variável) e `value` (valor, entre aspas duplas para valores com caracteres especiais como `#`).
    - A variável `LOCALHOST` é adicionada para testes, apontando para `http://localhost:3333`.
  - **Nota**: Os valores reais das variáveis (ex.: `SECRET_ACCESS`) não são mostrados na aula, mas devem ser preenchidos com base nas configurações do Cloudflare.

## Execução e Validação
- **Aplicação do YAML**:
  - **Comando `kubectl delete -f k8s/pod.yaml`**:
    - Deleta o pod anterior, que estava em **CrashLoopBackOff**. Como o namespace `widget` está especificado no `pod.yaml` (`metadata.namespace`), não é necessário passar `-n widget` no comando.
  - **Comando `kubectl apply -f k8s/pod.yaml`**:
    - Reaplica o `pod.yaml` atualizado, criando o pod no namespace `widget`.
  - **Comando `kubectl get pods -n widget`**:
    - Confirma que o pod `widget-server` está no estado **Running**, indicando que as variáveis de ambiente resolveram o problema de validação do Zod.
- **Verificação dos Logs**:
  - **Comando `kubectl logs -n widget widget-server`**:
    - Mostra a mensagem `HTTP server running`, confirmando que a aplicação está funcionando corretamente no cluster.
- **Mecanismo de Self-Healing**:
  - O Kubernetes detectou o crash anterior (devido ao erro do Zod) e reiniciou o pod automaticamente, demonstrando o comportamento de **self-healing**.
  - O **Kubelet** (agente em cada nó) comunica-se com o **Control Plane** para monitorar e reagendar pods em caso de falhas.
  - O pod é **descartável**, permitindo que o Kubernetes o recrie sem perda de funcionalidade, desde que o estado desejado esteja definido no YAML.

## Acesso à Aplicação
- **Comando `kubectl port-forward`**:
  - Usado para mapear uma porta local para a porta do contêiner no pod, permitindo acesso à aplicação.
  - **Comando**: `kubectl port-forward pod/widget-server -n widget 3333:3333`
    - Mapeia a porta 3333 da máquina local para a porta 3333 do contêiner no pod `widget-server` no namespace `widget`.
    - Similar ao `docker run -p 3333:3333`, mas aplicado ao contexto do Kubernetes.
  - **Erro Inicial**: Executar `kubectl port-forward` sem `-n widget` tenta acessar o pod no namespace `default`, resultando em erro. Após corrigir com `-n widget`, o comando funciona.
- **Teste de Acesso**:
  - Acessando `http://localhost:3333/health`, a aplicação retorna um erro **404 Not Found**, indicando que a rota `/health` não está disponível na versão do contêiner (`danielrodrigues/widget-server:D49E8862`).
  - **Hipótese**: A imagem no Docker Hub pode não incluir a rota `/health`, possivelmente devido a uma versão desatualizada ou configuração incorreta.
  - **Próximos Passos**: Investigar na próxima aula se o erro é devido à versão da imagem ou à ausência da rota `/health`. Um teste com `/healthz` também retorna 404, reforçando a necessidade de verificar o código da aplicação.

## Detalhes do Pod no Cluster
- **Comando `kubectl describe pod widget-server -n widget`**:
  - Fornece informações detalhadas sobre o pod:
    - **Node**: O pod foi agendado no nó `worker2`.
    - **IP**: O pod possui um IP interno (`10.244.1.4`), usado dentro do cluster, mas não acessível externamente.
    - **Imagem**: A imagem `danielrodrigues/widget-server:D49E8862` já estava presente no nó, então o Kubernetes não precisou baixá-la novamente.
    - **Eventos**: Mostra que o pod foi **escalonado** com sucesso pelo **scheduler** do **Control Plane** e que o **Kubelet** criou e iniciou o contêiner.
- **Imutabilidade de Tags**:
  - O Kubernetes, por padrão, não baixa novamente uma imagem com a mesma tag se ela já existe no nó, reforçando a importância de usar tags únicas para cada versão da aplicação.
  - Se a aplicação for atualizada sem mudar a tag, o Kubernetes não aplicará a nova versão, exigindo imutabilidade nas tags para garantir atualizações corretas.

## Observações e Boas Práticas
- **Variáveis de Ambiente**:
  - Definir variáveis diretamente no `pod.yaml` é aceitável para testes, mas em ambientes produtivos, **ConfigMaps** ou **Secrets** são recomendados para gerenciar configurações e dados sensíveis.
  - A aula opta por simplicidade, adiando o uso de **ConfigMap** para futuras explorações.
- **Namespace no YAML**:
  - Especificar `metadata.namespace: widget` no `pod.yaml` elimina a necessidade de passar `-n widget` em comandos como `kubectl apply` ou `kubectl delete`, reduzindo erros.
  - Se o namespace especificado no YAML não existir, o Kubernetes retorna um erro, garantindo consistência.
- **Port-Forward**:
  - Útil para testes locais, mas não é uma solução para ambientes produtivos, onde serviços como **Service** ou **Ingress** são usados para expor aplicações.
- **Limitações do Pod**:
  - A aula levanta a questão de se um pod isolado é suficiente para cenários reais, sugerindo que recursos como **Deployments** (para gerenciar réplicas e atualizações) podem ser necessários. Isso será explorado em aulas futuras.

## Conclusão
A aula resolve o erro **CrashLoopBackOff** do pod `widget-server` ao adicionar variáveis de ambiente no arquivo `pod.yaml`, permitindo que a aplicação rode com sucesso no namespace `widget`. O mecanismo de **self-healing** do Kubernetes é demonstrado, assim como o uso do `kubectl port-forward` para acessar a aplicação localmente. Um erro 404 na rota `/health` indica um possível problema com a versão da imagem no Docker Hub, que será investigado na próxima aula. A aula também questiona se um pod isolado é suficiente, preparando para a exploração de recursos mais avançados, como **Deployments**, e reforça a importância de práticas declarativas e imutabilidade de tags.