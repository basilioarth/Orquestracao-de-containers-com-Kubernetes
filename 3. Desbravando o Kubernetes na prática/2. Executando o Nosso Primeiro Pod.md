# Resumo da Aula sobre Criação de um Pod no Kubernetes para Executar a Aplicação Widget Server

## Introdução
A aula aborda a execução da aplicação **Widget Server** em um cluster Kubernetes configurado com o **Kind**, utilizando o namespace `widget` criado anteriormente. O foco é a criação de um **pod**, a menor unidade do Kubernetes, de forma declarativa por meio de um arquivo YAML. A aula explora boas práticas, como evitar comandos imperativos, e identifica um erro na execução do pod devido à ausência de variáveis de ambiente, preparando para a correção na próxima aula.

## Recapitulando o Ambiente
- **Cluster Configurado**:
  - O cluster possui um **Control Plane** e dois **Worker Nodes**, configurados via `kind.yaml`.
  - O namespace `widget` foi criado de forma declarativa com o arquivo `namespace.yaml` na pasta `infra`.
- **Boa Prática**:
  - Evitar o namespace `default` para aplicações, já que ele não oferece contexto claro sobre a aplicação ou time responsável.
  - Usar namespaces específicos (ex.: `widget`) para organização lógica, especialmente em clusters compartilhados por múltiplos times.

## Criação do Pod
- **Conceito de Pod**:
  - O **pod** é a menor unidade gerenciável do Kubernetes, capaz de executar um ou mais contêineres.
  - Geralmente, um pod executa uma única aplicação (um contêiner), mas pode incluir contêineres adicionais para funções específicas, como proxies ou sidecars (ex.: Vault, Istio).
  - **Antipadrão**: Rodar múltiplas aplicações no mesmo pod (ex.: front-end e back-end juntos). Cada aplicação deve ter seu próprio pod para garantir isolamento.
- **Boa Prática (YAML Declarativo)**:
  - Evitar comandos imperativos como `kubectl create pod`, pois não deixam histórico e dificultam a reprodutibilidade.
  - Criar arquivos YAML para definir pods, mantendo configurações versionadas e portáteis.
- **Organização de Arquivos**:
  - Configurações de cluster (ex.: `kind.yaml`, `namespace.yaml`) ficam na pasta `infra`.
  - Configurações de aplicações (ex.: pods, deployments) ficam na pasta `k8s` dentro do repositório da aplicação (`ftr-upload-widget-server`), seguindo a convenção `K8S` (de Kubernetes, com 8 letras entre K e S).
  - Em organizações maiores, YAMLs são frequentemente **templatizados** (ex.: com Helm ou Kustomize) para escalabilidade, com configurações mínimas no repositório da aplicação.

## Criação do Arquivo `pod.yaml`
- **Estrutura do Arquivo**:
  - Criado na pasta `k8s/pod.yaml` dentro do repositório da aplicação.
  - Conteúdo:
    ```yaml
    apiVersion: v1
    kind: Pod
    metadata:
      name: widget-server
      namespace: widget
    spec:
      containers:
      - name: widget-server
        image: danielrodrigues/widget-server:D49E8862
        ports:
        - containerPort: 3333
    ```
  - **Explicação**:
    - `apiVersion: v1`: Usa a API estável do Kubernetes para pods.
    - `kind: Pod`: Define o tipo de recurso como pod.
    - `metadata.name`: Nomeia o pod como `widget-server`.
    - `metadata.namespace`: Especifica o namespace `widget` para evitar o `default`.
    - `spec.containers`: Lista os contêineres do pod (neste caso, apenas um).
      - `name`: Nomeia o contêiner como `widget-server`.
      - `image`: Referencia a imagem do Docker Hub (`danielrodrigues/widget-server:D49E8862`), com uma tag específica (evitando `latest` para ambientes produtivos).
      - `ports.containerPort`: Expõe a porta 3333, conforme definido no `Dockerfile` da aplicação.
- **Observação sobre Tags**:
  - Usar tags específicas (ex.: `D49E8862`) em vez de `latest` para garantir rastreabilidade e facilitar rollbacks, uma prática também vista no AWS ECS.
  - Em ambientes produtivos, associar a tag ao commit da aplicação é essencial.

## Execução e Validação do Pod
- **Comando `kubectl apply -f k8s/pod.yaml`**:
  - Aplica o arquivo `pod.yaml`, criando o pod no namespace `widget`.
  - O kubectl usa o **kubeconfig** (`~/.kube/config`) para se conectar ao cluster `kind-ftr-k8s`.
- **Dica de Aplicação**:
  - É possível aplicar todos os arquivos YAML de uma pasta com `kubectl apply -f k8s/`, útil quando há múltiplos recursos.
  - O Kubernetes verifica o estado atual e só aplica mudanças necessárias, evitando recriação de recursos inalterados.
- **Verificação**:
  - **Erro Inicial**: Executando `kubectl get pods` (sem `-n`), o pod aparece no namespace `default`, indicando que o campo `metadata.namespace` não estava no YAML inicialmente.
  - **Correção**: Após adicionar `namespace: widget` ao `pod.yaml` e reaplicar com `kubectl apply -f k8s/pod.yaml`, o pod é criado no namespace `widget`.
  - **Comando `kubectl get pods -n widget`**: Confirma que o pod `widget-server` foi criado no namespace correto.
  - **Comando `kubectl delete -f k8s/pod.yaml`**: Usado para deletar o pod durante testes, especialmente quando criado no namespace errado.

## Problema Identificado
- **Erro de Execução**:
  - O pod é criado, mas entra em estado de **CrashLoopBackOff**, indicando que o contêiner está reiniciando repetidamente.
  - **Causa**: A aplicação **Widget Server** requer variáveis de ambiente (validadas pelo Zod), que não foram especificadas no `pod.yaml`.
  - **Comando `kubectl logs -n widget widget-server`**: Mostra que o erro está relacionado à validação do Zod, semelhante a um problema visto no módulo de AWS ECS.
- **Solução**: Será abordada na próxima aula, adicionando variáveis de ambiente ao `pod.yaml`.

## Conclusão
A aula demonstra a criação de um pod para executar a aplicação **Widget Server** no namespace `widget`, reforçando a importância de configurações declarativas com YAML. A separação entre configurações de cluster (`infra`) e aplicação (`k8s`) é destacada, assim como a necessidade de especificar o namespace correto no YAML. O erro de **CrashLoopBackOff** devido à falta de variáveis de ambiente é identificado, e a correção será explorada na próxima aula, junto com uma análise de se o pod sozinho é suficiente ou se outros recursos (ex.: deployments) serão necessários.