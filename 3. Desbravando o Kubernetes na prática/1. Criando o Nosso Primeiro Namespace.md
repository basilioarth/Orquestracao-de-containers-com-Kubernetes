# Resumo da Aula sobre Configuração de Namespace e Preparação para Executar Aplicações no Kubernetes

## Introdução
A aula consolida a configuração do cluster Kubernetes criado anteriormente com o **Kind**, destacando a estrutura com um **Control Plane** e dois **Worker Nodes**, configurados via arquivo YAML declarativo. O foco é a criação de um **namespace** personalizado para organizar aplicações, reforçando a importância de práticas declarativas no Kubernetes. O professor também prepara o terreno para executar a aplicação **Widget Server** no cluster, utilizando o namespace criado.

## Verificação do Cluster
- **Recapitulando**:
  - O cluster foi configurado com o arquivo `kind.yaml`, definindo um nó **control-plane** e dois nós **worker**, totalizando três nós.
  - **Comando `docker ps`**:
    - Confirma a execução de três contêineres Docker, cada um representando um nó (um **control-plane** e dois **worker**).
    - Contrasta com o cluster inicial (criado com `kind create cluster`), que tinha apenas um nó compartilhado, misturando **Control Plane** e **Worker Node** (má prática).
  - **Recursos da Máquina**:
    - Cada nó consome recursos locais, mas a configuração com três nós é suficiente para testes.
    - Para máquinas com hardware limitado, é possível usar apenas um **Worker Node** sem problemas, embora a aula mantenha dois para explorar distribuição de carga.

## Importância do Namespace
- **Conceito**:
  - Namespaces são divisões **lógicas** no cluster, permitindo organizar recursos (pods, deployments, etc.) por times, aplicações ou unidades de negócio (BUs).
  - Diferem de nós, que são divisões **físicas** (máquinas ou instâncias em ambientes produtivos; contêineres no Kind).
- **Namespaces Padrão**:
  - **Comando `kubectl get namespaces`** (ou `kubectl get ns`):
    - Lista os namespaces padrão criados pelo Kubernetes: `default`, `kube-node-lease`, `kube-public`, `kube-system` e `local-path-storage` (relacionado ao Kind).
    - Namespaces com prefixo `kube-` são usados pelo Kubernetes para componentes do sistema (ex.: `kube-system` para **Control Plane**).
  - **Por que evitar o namespace `default`?**:
    - Aplicações no namespace `default` não têm contexto claro (ex.: qual time ou BU é responsável?), dificultando rastreabilidade e organização.
    - Em clusters reais, múltiplos times compartilham o mesmo cluster, e namespaces ajudam a segmentar aplicações (ex.: `payments`, `accounts`).
- **Boa Prática**:
  - Criar namespaces específicos para cada contexto (ex.: por time, BU ou aplicação).
  - Exemplo: Um namespace `payments` para aplicações de uma BU de pagamentos, ou `users` para serviços relacionados a usuários.

## Criação de Namespace
- **Má Prática (Comando Imperativo)**:
  - **Comando `kubectl create namespace widget`**:
    - Cria o namespace `widget` de forma imperativa.
    - Problema: Sem um arquivo declarativo, não há histórico da configuração, dificultando recriação após deleção do cluster.
  - **Comando `kubectl delete namespace widget`**:
    - Deleta o namespace criado, usado para demonstrar a má prática do uso imperativo.
  - **Comando `kubectl get ns`**:
    - Confirma que o namespace `widget` foi removido.
- **Boa Prática (YAML Declarativo)**:
  - Criado um arquivo `namespace.yaml` na pasta `infra` para definir o namespace de forma declarativa:
    ```yaml
    apiVersion: v1
    kind: Namespace
    metadata:
      name: widget
    ```
  - **Explicação**:
    - `apiVersion: v1`: Usa a versão estável da API do Kubernetes para namespaces.
    - `kind: Namespace`: Define o tipo de recurso como namespace.
    - `metadata.name: widget`: Nomeia o namespace como `widget`.
  - **Vantagem**:
    - Permite versionamento e recriação consistente do namespace em novos clusters.
    - Um único arquivo pode conter múltiplos namespaces (ex.: `widget`, `widget2`), separados por `---`, embora a aula use apenas um para simplicidade.
- **Comando `kubectl apply -f infra/namespace.yaml`**:
  - Aplica o arquivo YAML, criando o namespace `widget`.
  - O kubectl usa o **kubeconfig** (`~/.kube/config`) para se conectar ao cluster `kind-ftr-k8s`.
  - **Comando `kubectl get ns`**:
    - Confirma a criação do namespace `widget`.

## Preparação para Executar Aplicações
- **Aplicação Widget Server**:
  - Já está publicada no **Docker Hub**, com tags geradas automaticamente a cada commit, facilitando o uso em ambientes remotos.
  - Pode ser baixada pelo Kubernetes diretamente do Docker Hub, simplificando a configuração em comparação com repositórios locais.
- **Próximos Passos**:
  - Criar arquivos YAML adicionais para definir recursos como pods ou deployments no namespace `widget`.
  - Evitar comandos imperativos (ex.: `kubectl create pod`) para manter a prática declarativa, garantindo portabilidade e rastreabilidade.
  - A aplicação será executada nos **Worker Nodes**, não no **Control Plane**, respeitando a separação de responsabilidades.

## Dicas e Observações
- **Abreviações no Kubectl**:
  - O comando `kubectl get namespaces` pode ser abreviado como `kubectl get ns` (de "namespace").
  - A abreviação funciona para outros recursos (ex.: `po` para pods, `deploy` para deployments), aumentando a produtividade.
- **Organização de Arquivos**:
  - Configurações de cluster (ex.: `kind.yaml`, `namespace.yaml`) ficam na pasta `infra`.
  - Configurações de aplicações (ex.: pods, deployments) devem ficar próximas ao código da aplicação, idealmente no mesmo repositório.
- **Portabilidade do Kubernetes**:
  - Arquivos YAML garantem que configurações possam ser reaplicadas em diferentes clusters (ex.: local, AWS EKS), desde que o **kubeconfig** esteja configurado corretamente.

## Conclusão
A aula reforça a configuração do cluster Kubernetes com **Kind**, destacando a separação entre **Control Plane** e **Worker Nodes** e a importância de namespaces para organização lógica. A criação do namespace `widget` é demonstrada de forma imperativa (má prática) e declarativa (boa prática), com ênfase no uso de arquivos YAML para rastreabilidade. A aplicação **Widget Server** será usada nas próximas aulas para explorar objetos como pods e deployments no namespace `widget`, aplicando conceitos teóricos de forma prática.



# Resumo da Aula sobre Configuração de Namespace e Preparação para Executar Aplicações no Kubernetes

## Introdução
A aula consolida a configuração do cluster Kubernetes criado anteriormente com o **Kind**, destacando a estrutura com um **Control Plane** e dois **Worker Nodes**, configurados via arquivo YAML declarativo. O foco é a criação de um **namespace** personalizado para organizar aplicações, reforçando a importância de práticas declarativas no Kubernetes. O professor também prepara o terreno para executar a aplicação **Widget Server** no cluster, utilizando o namespace criado.

## Verificação do Cluster
- **Recapitulando**:
  - O cluster foi configurado com o arquivo `kind.yaml`, definindo um nó **control-plane** e dois nós **worker**, totalizando três nós.
  - **Comando `docker ps`**:
    - Confirma a execução de três contêineres Docker, cada um representando um nó (um **control-plane** e dois **worker**).
    - Contrasta com o cluster inicial (criado com `kind create cluster`), que tinha apenas um nó compartilhado, misturando **Control Plane** e **Worker Node** (má prática).
  - **Recursos da Máquina**:
    - Cada nó consome recursos locais, mas a configuração com três nós é suficiente para testes.
    - Para máquinas com hardware limitado, é possível usar apenas um **Worker Node** sem problemas, embora a aula mantenha dois para explorar distribuição de carga.

## Importância do Namespace
- **Conceito**:
  - Namespaces são divisões **lógicas** no cluster, permitindo organizar recursos (pods, deployments, etc.) por times, aplicações ou unidades de negócio (BUs).
  - Diferem de nós, que são divisões **físicas** (máquinas ou instâncias em ambientes produtivos; contêineres no Kind).
- **Namespaces Padrão**:
  - **Comando `kubectl get namespaces`** (ou `kubectl get ns`):
    - Lista os namespaces padrão criados pelo Kubernetes: `default`, `kube-node-lease`, `kube-public`, `kube-system` e `local-path-storage` (relacionado ao Kind).
    - Namespaces com prefixo `kube-` são usados pelo Kubernetes para componentes do sistema (ex.: `kube-system` para **Control Plane**).
  - **Por que evitar o namespace `default`?**:
    - Aplicações no namespace `default` não têm contexto claro (ex.: qual time ou BU é responsável?), dificultando rastreabilidade e organização.
    - Em clusters reais, múltiplos times compartilham o mesmo cluster, e namespaces ajudam a segmentar aplicações (ex.: `payments`, `accounts`).
- **Boa Prática**:
  - Criar namespaces específicos para cada contexto (ex.: por time, BU ou aplicação).
  - Exemplo: Um namespace `payments` para aplicações de uma BU de pagamentos, ou `users` para serviços relacionados a usuários.

## Criação de Namespace
- **Má Prática (Comando Imperativo)**:
  - **Comando `kubectl create namespace widget`**:
    - Cria o namespace `widget` de forma imperativa.
    - Problema: Sem um arquivo declarativo, não há histórico da configuração, dificultando recriação após deleção do cluster.
  - **Comando `kubectl delete namespace widget`**:
    - Deleta o namespace criado, usado para demonstrar a má prática do uso imperativo.
  - **Comando `kubectl get ns`**:
    - Confirma que o namespace `widget` foi removido.
- **Boa Prática (YAML Declarativo)**:
  - Criado um arquivo `namespace.yaml` na pasta `infra` para definir o namespace de forma declarativa:
    ```yaml
    apiVersion: v1
    kind: Namespace
    metadata:
      name: widget
    ```
  - **Explicação**:
    - `apiVersion: v1`: Usa a versão estável da API do Kubernetes para namespaces.
    - `kind: Namespace`: Define o tipo de recurso como namespace.
    - `metadata.name: widget`: Nomeia o namespace como `widget`.
  - **Vantagem**:
    - Permite versionamento e recriação consistente do namespace em novos clusters.
    - Um único arquivo pode conter múltiplos namespaces (ex.: `widget`, `widget2`), separados por `---`, embora a aula use apenas um para simplicidade.
- **Comando `kubectl apply -f infra/namespace.yaml`**:
  - Aplica o arquivo YAML, criando o namespace `widget`.
  - O kubectl usa o **kubeconfig** (`~/.kube/config`) para se conectar ao cluster `kind-ftr-k8s`.
  - **Comando `kubectl get ns`**:
    - Confirma a criação do namespace `widget`.

## Preparação para Executar Aplicações
- **Aplicação Widget Server**:
  - Já está publicada no **Docker Hub**, com tags geradas automaticamente a cada commit, facilitando o uso em ambientes remotos.
  - Pode ser baixada pelo Kubernetes diretamente do Docker Hub, simplificando a configuração em comparação com repositórios locais.
- **Próximos Passos**:
  - Criar arquivos YAML adicionais para definir recursos como pods ou deployments no namespace `widget`.
  - Evitar comandos imperativos (ex.: `kubectl create pod`) para manter a prática declarativa, garantindo portabilidade e rastreabilidade.
  - A aplicação será executada nos **Worker Nodes**, não no **Control Plane**, respeitando a separação de responsabilidades.

## Dicas e Observações
- **Abreviações no Kubectl**:
  - O comando `kubectl get namespaces` pode ser abreviado como `kubectl get ns` (de "namespace").
  - A abreviação funciona para outros recursos (ex.: `po` para pods, `deploy` para deployments), aumentando a produtividade.
- **Organização de Arquivos**:
  - Configurações de cluster (ex.: `kind.yaml`, `namespace.yaml`) ficam na pasta `infra`.
  - Configurações de aplicações (ex.: pods, deployments) devem ficar próximas ao código da aplicação, idealmente no mesmo repositório.
- **Portabilidade do Kubernetes**:
  - Arquivos YAML garantem que configurações possam ser reaplicadas em diferentes clusters (ex.: local, AWS EKS), desde que o **kubeconfig** esteja configurado corretamente.

## Conclusão
A aula reforça a configuração do cluster Kubernetes com **Kind**, destacando a separação entre **Control Plane** e **Worker Nodes** e a importância de namespaces para organização lógica. A criação do namespace `widget` é demonstrada de forma imperativa (má prática) e declarativa (boa prática), com ênfase no uso de arquivos YAML para rastreabilidade. A aplicação **Widget Server** será usada nas próximas aulas para explorar objetos como pods e deployments no namespace `widget`, aplicando conceitos teóricos de forma prática.

