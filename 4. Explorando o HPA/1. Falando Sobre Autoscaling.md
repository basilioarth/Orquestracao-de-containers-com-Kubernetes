# Resumo da Aula sobre Introdução ao Horizontal Pod Autoscaler (HPA) no Kubernetes

## Introdução
A aula introduz o conceito de **Horizontal Pod Autoscaler (HPA)** no Kubernetes, abordando a escalabilidade horizontal para lidar com picos de tráfego na aplicação `widget-server`. Até agora, a aplicação foi configurada com **Deployment**, **ReplicaSet**, **Pods** e **Service**, com 5 réplicas inicialmente definidas. A aula destaca a necessidade de ajustar dinamicamente o número de réplicas com base na demanda, evitando configurações manuais baseadas em "chutômetro". O HPA automatiza a criação e remoção de pods com base em métricas como CPU e memória, otimizando recursos e custos. A aula também menciona a dependência de métricas externas para ativar o HPA, que será explorada na próxima aula, junto com a criação do arquivo declarativo para o HPA.

## Contexto e Hierarquia no Kubernetes
- **Recapitulando a Estrutura**:
  - **Comandos Executados**:
    - `kubectl get pods -n widget`: Exibe 5 réplicas (pods) da aplicação `widget-server`.
    - `kubectl get deployments -n widget`: Mostra o **Deployment** `widget-server`.
    - `kubectl get rs -n widget`: Lista o **ReplicaSet** associado, com um nome baseado no hash do **Deployment**.
  - **Hierarquia**:
    - **Deployment**: Define o nome (`widget-server`) e controla a estratégia de atualização (ex.: RollingUpdate).
    - **ReplicaSet**: Gerado automaticamente com um hash (ex.: `widget-server-<hash>`), gerencia a quantidade de réplicas.
    - **Pods**: Criados com nomes baseados no **Deployment** e **ReplicaSet** (ex.: `widget-server-<rs-hash>-<pod-hash>`).
  - **Configuração Atual** (baseada no `deployment.yaml`):
    - **Replicas**: 5 pods (alterado para 3 no exemplo para simplificação).
    - **Recursos por Pod**:
      - `requests`: 200m CPU (milicpu), 256Mi memória.
      - `limits`: 300m CPU, 384Mi memória.
    - **Total de Recursos (3 pods)**:
      - CPU: 600m (0,6 vCPU).
      - Memória: 768Mi (512Mi + 256Mi).
    - **Cluster**: Suporta 4000m CPU (4 vCPUs) e ~6Gi memória, suficiente para a aplicação.

- **Desafio do "Chutômetro"**:
  - No início (dia zero), a quantidade de réplicas e recursos é estimada, sem dados reais de tráfego.
  - Exemplo: A aplicação suporta **10 RPS** (requisições por segundo) com 3 pods, mas não está preparada para picos (ex.: **150 RPS**, aumento de 15x devido a promoções ou campanhas).
  - **Problema**:
    - 3 pods com 200m CPU e 256Mi memória não conseguem lidar com 150 RPS, causando lentidão ou falhas.
    - Aumentar manualmente para 20 pods (ex.: editando `replicas: 20` no `deployment.yaml`) é lento, não automático e pode ser inviável fora do expediente ou em cenários de pico abrupto.
  - **Risco**: Configurações manuais podem levar a loops de falha (pods não iniciam devido a sobrecarga) ou alocação excessiva de recursos, aumentando custos.

- **Boa Prática**:
  - **Mais Pods, Menos Recursos por Pod**: Favorece redundância e resiliência.
    - Ex.: 5 pods com 200m CPU cada é melhor que 2 pods com 500m CPU, pois reduz o impacto de falhas individuais.
  - **Escalabilidade Automática**: Necessária para lidar com picos de tráfego sem intervenção manual.

## Introdução ao Horizontal Pod Autoscaler (HPA)
- **Definição**:
  - O **HPA** (Horizontal Pod Autoscaler) ajusta automaticamente o número de réplicas de um **Deployment** ou **ReplicaSet** com base em métricas, como uso de CPU ou memória.
  - **Objetivo**:
    - Escalar horizontalmente (adicionar pods) durante picos de tráfego.
    - Realizar **downscaling** (remover pods) quando o tráfego diminui, otimizando custos.
  - **Funcionamento**:
    - Monitora métricas dos pods (ex.: uso de CPU/memória).
    - Compara com valores alvo definidos (ex.: 70% de uso de CPU).
    - Aumenta ou diminui o número de réplicas dentro de limites mínimo e máximo.
  - **Exemplo no Contexto**:
    - **Cenário Normal**: 10 RPS, 3 pods (600m CPU, 768Mi memória).
    - **Pico de Tráfego**: 150 RPS, HPA escala para 8 pods (1600m CPU, ~1,5Gi memória).
    - **Após o Pico**: HPA reduz para o mínimo (ex.: 3 pods) para economizar recursos.
  - **Vantagens**:
    - Automatiza a escalabilidade, eliminando ajustes manuais.
    - Evita indisponibilidade durante picos de tráfego.
    - Reduz custos ao remover pods desnecessários.

- **Métricas e Dependências**:
  - O HPA depende de métricas fornecidas por um componente externo, como o **Metrics Server**, que coleta dados de CPU e memória dos pods.
  - Sem métricas, o HPA não pode ser acionado, pois não sabe quando escalar.
  - **Nota**: A próxima aula detalhará a configuração do **Metrics Server** e do arquivo declarativo do HPA.

- **Comandos Iniciais**:
  - `kubectl get hpa -n widget`: Verifica se existe um HPA no namespace `widget` (nenhum configurado ainda).
  - `kubectl get horizontalpodautoscaler -n widget`: Mesmo resultado, usando o nome completo.
  - Confirma que o HPA é um recurso nativo do Kubernetes, pronto para configuração.

- **Pré-Escala Manual**:
  - Em cenários previsíveis (ex.: Black Friday, promoções), pode-se aumentar manualmente o número de réplicas com antecedência.
  - **Limitação**: Não substitui o HPA, que é essencial para picos inesperados ou ajustes dinâmicos.

## Configuração do HPA (Visão Geral)
- **Arquivo Declarativo**:
  - Será criado na próxima aula (`hpa.yaml`) para definir:
    - **Recurso Alvo**: O **Deployment** `widget-server`.
    - **Métricas**: Ex.: uso de CPU (percentual alvo, como 70%).
    - **Limites**: Número mínimo (ex.: 3 pods) e máximo (ex.: 10 pods) de réplicas.
  - **Formas de Configuração**:
    - **Legada**: Baseada em métricas simples de CPU/memória.
    - **Moderna (API)**: Suporta métricas customizadas (ex.: RPS, latência), mais flexível.
- **Fator Surpresa**:
  - O HPA depende de um componente externo (ex.: **Metrics Server**) para coletar métricas.
  - A próxima aula explorará como configurar esse componente e integrar com o HPA.

## Limitações e Observações
- **Chutômetro Inicial**:
  - Sem dados históricos, a configuração inicial de réplicas e recursos é estimada, exigindo ajustes baseados em testes e observabilidade.
- **Custo de Escala**:
  - Mais pods aumentam o uso de CPU/memória, impactando custos em clusters pagos (ex.: AWS EKS).
  - O **downscaling** do HPA é crucial para evitar alocação desnecessária de recursos.
- **Dependência de Métricas**:
  - O HPA não funciona sem um sistema de métricas (ex.: **Metrics Server** ou Prometheus).
  - Configurações inadequadas (ex.: limites muito altos) podem levar a escalas excessivas ou insuficientes.
- **Redundância**:
  - Múltiplos pods com recursos menores aumentam a resiliência, mas exigem monitoramento para evitar sobrecarga no cluster.
- **Pré-Escala**:
  - Útil para picos previsíveis, mas manual e menos flexível que o HPA.
- **Observabilidade**:
  - Ferramentas como Prometheus ou Grafana são recomendadas para monitorar picos, entender causas e validar ações do HPA.

## Próximos Passos
- **Configuração do HPA**:
  - Criar o arquivo `hpa.yaml` para definir o autoscaler, especificando métricas (CPU/memória) e limites de réplicas.
  - Explorar configurações legada e moderna (API).
- **Metrics Server**:
  - Configurar o componente que fornece métricas de CPU e memória para o HPA.
- **Testes Práticos**:
  - Simular picos de tráfego para validar a escalabilidade automática.
- **Tópicos Avançados**:
  - Continuar a exploração de **Secrets** (ex.: **ImagePullSecrets**).
  - Configurar **Ingress** para exposição pública da aplicação.
  - Integrar observabilidade para monitoramento detalhado.

## Conclusão
A aula apresenta o **Horizontal Pod Autoscaler (HPA)** como solução para escalabilidade automática no Kubernetes, destacando sua importância para lidar com picos de tráfego (ex.: de 10 RPS para 150 RPS) sem intervenção manual. A configuração atual do `widget-server` (3 pods, 200m CPU, 256Mi memória) é insuficiente para picos, e ajustes manuais são lentos e arriscados. O HPA automatiza a criação e remoção de pods com base em métricas de CPU/memória, otimizando recursos e custos. A dependência de um sistema de métricas (ex.: **Metrics Server**) é destacada, com detalhes a serem abordados na próxima aula, incluindo a criação do arquivo declarativo do HPA. A abordagem reforça boas práticas, como usar mais pods com menos recursos para maior redundância, preparando o terreno para configurações práticas e avançadas.