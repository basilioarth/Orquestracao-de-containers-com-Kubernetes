# Resumo da Aula sobre Objetos do Kubernetes nos Nós de Trabalho

## Introdução
A aula aborda os **objetos do Kubernetes** que operam nos **nós de trabalho** (worker nodes), detalhando como eles interagem com a **Kube API Server** para executar aplicações, gerenciar redes e armazenamento. O professor reforça a separação entre o **Control Plane** (gerenciamento) e os nós de trabalho (execução), destacando a importância de boas práticas, como a separação de nós e o uso de manifestos declarativos. A aula foca no contexto teórico, preparando para a prática futura, como a criação de pods e a instalação de um cluster Kubernetes.

## Contexto Geral
- **Separação de Funções**:
  - **Control Plane**: Gerencia o cluster, interagindo com a Kube API Server para orquestrar recursos.
  - **Worker Nodes**: Executam as aplicações em pods, sendo máquinas físicas ou virtuais que recebem instruções do Control Plane.
- **Boas Práticas**:
  - Um cluster deve ter pelo menos dois nós: um para o Control Plane e outro para o Worker, garantindo separação e resiliência.
  - Em cenários de alta disponibilidade, múltiplos nós (Control Plane e Workers) são recomendados.
  - O Control Plane usa **taints** para evitar que aplicações sejam agendadas nele.
- **Interação com a API**: Todos os objetos do Kubernetes, sejam de execução, rede ou armazenamento, interagem com a Kube API Server, geralmente via manifestos **YAML declarativos**, que são a prática recomendada (em oposição a comandos imperativos).

## Camadas e Objetos nos Nós de Trabalho
Os nós de trabalho suportam objetos em três camadas principais: **Workload**, **Rede** e **Armazenamento**.

### 1. Camada de Workload
- **Pod**:
  - Menor unidade do Kubernetes, responsável por executar um ou mais contêineres.
  - Cada pod recebe automaticamente um **endereço IP interno** no cluster para comunicação.
  - Stateless por padrão, mas pode ser configurado para suportar estado com volumes.
  - Não possui mecanismos nativos de controle (ex.: restart automático ou gerenciamento de réplicas).
- **ReplicaSet**:
  - Controla a quantidade de pods (réplicas) em execução, garantindo que o número desejado esteja ativo.
  - Trabalha com o Scheduler e o Kubelet para reconciliar o estado (ex.: recriar pods se o número estiver abaixo do esperado).
- **Deployment**:
  - Gerencia versões de aplicações, controlando a **tag do contêiner** (ex.: v1, v2).
  - Hierarquicamente, um Deployment cria um ReplicaSet, que por sua vez gerencia os pods.
  - Suporta atualizações graduais e reconciliação para manter o estado desejado.
- **Outros Objetos**:
  - **ConfigMap**: Armazena configurações reutilizáveis para pods.
  - **Secret**: Gerencia dados sensíveis, como senhas ou chaves.
  - **Horizontal Pod Autoscaler (HPA)**: Escala pods automaticamente com base em métricas (ex.: uso de CPU).
  - **StatefulSet**: Usado para aplicações com estado (ex.: bancos de dados, Kafka), garantindo ordem e persistência.

### 2. Camada de Rede
- **Service**: Define um conjunto de pods e uma política de acesso, permitindo balanceamento de carga e **Service Discovery**.
- **Ingress**: Gerencia o tráfego externo para serviços, geralmente via HTTP, com regras de roteamento.
- **Gateway**: Um CRD (Custom Resource Definition) que estende a API para configurações avançadas de rede.
- **Endpoints**: Mapeiam serviços a endereços de pods, facilitando a comunicação.

### 3. Camada de Armazenamento
- **Persistent Volume (PV)**: Recurso que representa um volume de armazenamento no cluster.
- **Persistent Volume Claim (PVC)**: Solicitação de armazenamento feita por um pod, vinculada a um PV.
- Esses objetos permitem configurar volumes persistentes para suportar aplicações stateful, como bancos de dados.

## Interação com a API e Boas Práticas
- **Manifestos Declarativos**:
  - A criação de objetos (pods, ReplicaSets, Deployments, etc.) deve ser feita via arquivos YAML, que especificam o recurso da API e seu tipo.
  - Comandos imperativos (ex.: via linha de comando) são possíveis, mas não recomendados, pois dificultam rastreabilidade e versionamento.
- **CRDs (Custom Resource Definitions)**:
  - Permitem estender a API do Kubernetes, adicionando recursos personalizados (ex.: Gateway).
  - Ferramentas instaladas no cluster frequentemente usam CRDs para integrar funcionalidades, mantendo a mesma lógica de YAML declarativo.
- **Integração com a Kube API**:
  - Todos os objetos interagem com a Kube API Server, que processa os manifestos e coordena ações com o Scheduler e Kubelet.
  - Mesmo em clusters com um único nó (má prática), os objetos estão disponíveis, pois residem na API, não no nó físico.

## Observações sobre o Control Plane
- O Control Plane também possui pods (ex.: para o Controller Manager ou Cloud Controller Manager), mas esses são gerenciados automaticamente pelo Kubernetes.
- Em clusters gerenciados, o provedor de nuvem cuida desses pods, enquanto em clusters locais, o usuário pode precisar intervir em caso de problemas.

## Conclusão
A aula detalha os **objetos do Kubernetes** que operam nos nós de trabalho, organizados em camadas de **workload** (Pod, ReplicaSet, Deployment, ConfigMap, Secret, HPA, StatefulSet), **rede** (Service, Ingress, Gateway, Endpoints) e **armazenamento** (PV, PVC). Esses objetos interagem com a **Kube API Server** via manifestos YAML declarativos, garantindo flexibilidade e rastreabilidade. A aula reforça a importância de boas práticas, como a separação entre Control Plane e Worker Nodes, e prepara para as próximas sessões, que abordarão a API do Kubernetes, a instalação de um cluster e a criação prática de pods para explorar problemas e soluções.