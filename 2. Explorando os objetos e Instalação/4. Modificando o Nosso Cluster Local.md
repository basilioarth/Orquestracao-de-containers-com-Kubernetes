# Resumo da Aula sobre Configuração de Cluster Kubernetes com Kind e Introdução a Namespaces

## Introdução
A aula dá continuidade à criação de um cluster Kubernetes local usando o **Kind**, focando na configuração correta para incluir **Worker Nodes** separados do **Control Plane**, seguindo boas práticas. O professor demonstra a deleção do cluster anterior, a criação de um novo cluster com um arquivo YAML declarativo e a exploração de conceitos como **namespaces**. A aula também prepara para as próximas sessões, que abordarão a execução de aplicações no cluster.

## Verificação do Ambiente
- **Comando `docker ps`**:
  - Exibe os contêineres em execução, confirmando que o cluster anterior criado com `kind create cluster` possui apenas um contêiner (o nó do **Control Plane**).
  - Reforça que o cluster inicial tinha apenas um nó compartilhado, misturando **Control Plane** e **Worker Node**, o que não é ideal.
- **Comando `kubectl get nodes`**:
  - Após a deleção do cluster, retorna um erro (`connection refused`), indicando que não há cluster ativo, já que a API do Kubernetes não está disponível.
- **Comando `kubectl version`**:
  - Também retorna erro, confirmando que nenhum cluster está em execução.

## Deleção do Cluster
- **Comando `kind delete cluster`**:
  - Deleta o cluster padrão criado anteriormente (nomeado `kind-kind`).
  - Se houver múltiplos clusters, pode-se especificar o nome com `--name` (ex.: `kind delete cluster --name ftr-k8s`).
  - Após a deleção, nenhum contêiner do Kind aparece no `docker ps`, e o cluster é removido.

## Criação de Cluster com YAML Declarativo
- **Boa Prática**:
  - Usar arquivos YAML declarativos para criar clusters, assim como para outros recursos do Kubernetes, garantindo rastreabilidade e reprodutibilidade.
  - Similar à criação de infraestrutura em provedores de nuvem (ex.: AWS com Terraform ou Pulumi), onde a configuração declarativa é preferida.
- **Arquivo `kind.yaml`**:
  - Criado em uma pasta de trabalho (`infra/kind.yaml`) para definir a configuração do cluster.
  - Estrutura do arquivo:
    ```yaml
    apiVersion: kind.x-k8s.io/v1alpha4
    kind: Cluster
    name: ftr-k8s
    nodes:
      - role: control-plane
      - role: worker
      - role: worker
    ```
  - **Explicação**:
    - `apiVersion: kind.x-k8s.io/v1alpha4`: Define a versão da API do Kind.
    - `kind: Cluster`: Especifica o tipo de recurso (um cluster).
    - `name: ftr-k8s`: Nomeia o cluster (evita o uso de `--name` no comando imperativo).
    - `nodes`: Lista os nós do cluster, com um nó **control-plane** e dois nós **worker**.
  - **Nota**: O `kind` no arquivo YAML refere-se ao tipo de recurso (`Cluster`), não à ferramenta Kind (Kubernetes in Docker).
- **Comando `kind create cluster --config infra/kind.yaml`**:
  - Cria o cluster com base no arquivo YAML.
  - Gera três contêineres Docker (um para o **Control Plane** e dois para **Worker Nodes**), visíveis com `docker ps`.
  - Configura automaticamente o **kubeconfig** (`~/.kube/config`) com o contexto `kind-ftr-k8s`.
  - A criação é mais rápida se a imagem do nó (ex.: `kindest/node:v1.33.1`) já estiver baixada.

## Verificação do Novo Cluster
- **Comando `kubectl get nodes`**:
  - Lista três nós: um **control-plane** e dois **worker**.
  - Confirma a separação correta entre **Control Plane** e **Worker Nodes**, seguindo a boa prática.
- **Comando `kubectl get pods --all-namespaces`**:
  - Exibe pods no namespace `kube-system`, incluindo:
    - **CoreDNS**, **etcd**, **kube-apiserver**, **kube-controller-manager**, **kube-scheduler** (relacionados ao **Control Plane**).
    - **kube-proxy**: Três instâncias, uma por nó (um no **Control Plane** e uma em cada **Worker Node**).
    - **local-path-storage**: Relacionado ao armazenamento do Kind.
  - No namespace padrão, `kubectl get pods` retorna "No resources found", pois ainda não há aplicações.
- **Kubeconfig**:
  - O arquivo `~/.kube/config` é atualizado com o contexto `kind-ftr-k8s`, contendo informações de autenticação e o endereço do servidor da API.
  - Todos os comandos `kubectl` usam esse arquivo para se conectar ao cluster.

## Introdução a Namespaces
- **Definição**:
  - Namespaces são divisões **lógicas** no cluster, ao contrário dos nós, que são divisões **físicas**.
  - Usados para organizar recursos (ex.: pods, deployments) por grupos de aplicações ou equipes (ex.: `users`, `payments`).
- **Namespace Padrão**:
  - O namespace `default` é usado automaticamente se nenhum outro for especificado.
  - Não é boa prática rodar aplicações no namespace `default`, pois dificulta a organização e rastreabilidade.
- **Exemplo de Uso**:
  - `kubectl get pods -n kube-system`: Lista pods no namespace `kube-system`, onde residem os componentes do **Control Plane**.
  - `kubectl get pods -n local-path-storage`: Mostra pods específicos desse namespace (ex.: armazenamento do Kind).
  - `kubectl get pods --all-namespaces`: Lista pods de todos os namespaces, incluindo os do **Control Plane** e outros.
- **Importância**:
  - Namespaces ajudam a segregar aplicações, facilitando gerenciamento e evitando conflitos.
  - O **Control Plane** (ex.: pods no `kube-system`) não recebe cargas de trabalho de aplicações, apenas suas próprias responsabilidades.

## Conclusão
A aula avança na configuração de um cluster Kubernetes local com o **Kind**, corrigindo o problema do cluster anterior (nó compartilhado) ao criar um cluster com um **Control Plane** e dois **Worker Nodes** usando um arquivo YAML declarativo. A separação de nós segue as boas práticas, e a introdução de **namespaces** destaca a importância da organização lógica de recursos. Comandos como `kubectl get nodes` e `kubectl get pods --all-namespaces` confirmam o funcionamento do cluster, enquanto o **kubeconfig** garante a conexão. A aula prepara para as próximas sessões, que explorarão a execução de aplicações no cluster, começando a aplicar conceitos práticos.



# Resumo da Aula sobre Configuração de Cluster Kubernetes com Kind e Introdução a Namespaces

## Introdução
A aula dá continuidade à criação de um cluster Kubernetes local usando o **Kind**, focando na configuração correta para incluir **Worker Nodes** separados do **Control Plane**, seguindo boas práticas. O professor demonstra a deleção do cluster anterior, a criação de um novo cluster com um arquivo YAML declarativo e a exploração de conceitos como **namespaces**. A aula também prepara para as próximas sessões, que abordarão a execução de aplicações no cluster.

## Verificação do Ambiente
- **Comando `docker ps`**:
  - Exibe os contêineres em execução, confirmando que o cluster anterior criado com `kind create cluster` possui apenas um contêiner (o nó do **Control Plane**).
  - Reforça que o cluster inicial tinha apenas um nó compartilhado, misturando **Control Plane** e **Worker Node**, o que não é ideal.
- **Comando `kubectl get nodes`**:
  - Após a deleção do cluster, retorna um erro (`connection refused`), indicando que não há cluster ativo, já que a API do Kubernetes não está disponível.
- **Comando `kubectl version`**:
  - Também retorna erro, confirmando que nenhum cluster está em execução.

## Deleção do Cluster
- **Comando `kind delete cluster`**:
  - Deleta o cluster padrão criado anteriormente (nomeado `kind-kind`).
  - Se houver múltiplos clusters, pode-se especificar o nome com `--name` (ex.: `kind delete cluster --name ftr-k8s`).
  - Após a deleção, nenhum contêiner do Kind aparece no `docker ps`, e o cluster é removido.

## Criação de Cluster com YAML Declarativo
- **Boa Prática**:
  - Usar arquivos YAML declarativos para criar clusters, assim como para outros recursos do Kubernetes, garantindo rastreabilidade e reprodutibilidade.
  - Similar à criação de infraestrutura em provedores de nuvem (ex.: AWS com Terraform ou Pulumi), onde a configuração declarativa é preferida.
- **Arquivo `kind.yaml`**:
  - Criado em uma pasta de trabalho (`infra/kind.yaml`) para definir a configuração do cluster.
  - Estrutura do arquivo:
    ```yaml
    apiVersion: kind.x-k8s.io/v1alpha4
    kind: Cluster
    name: ftr-k8s
    nodes:
      - role: control-plane
      - role: worker
      - role: worker
    ```
  - **Explicação**:
    - `apiVersion: kind.x-k8s.io/v1alpha4`: Define a versão da API do Kind.
    - `kind: Cluster`: Especifica o tipo de recurso (um cluster).
    - `name: ftr-k8s`: Nomeia o cluster (evita o uso de `--name` no comando imperativo).
    - `nodes`: Lista os nós do cluster, com um nó **control-plane** e dois nós **worker**.
  - **Nota**: O `kind` no arquivo YAML refere-se ao tipo de recurso (`Cluster`), não à ferramenta Kind (Kubernetes in Docker).
- **Comando `kind create cluster --config infra/kind.yaml`**:
  - Cria o cluster com base no arquivo YAML.
  - Gera três contêineres Docker (um para o **Control Plane** e dois para **Worker Nodes**), visíveis com `docker ps`.
  - Configura automaticamente o **kubeconfig** (`~/.kube/config`) com o contexto `kind-ftr-k8s`.
  - A criação é mais rápida se a imagem do nó (ex.: `kindest/node:v1.33.1`) já estiver baixada.

## Verificação do Novo Cluster
- **Comando `kubectl get nodes`**:
  - Lista três nós: um **control-plane** e dois **worker**.
  - Confirma a separação correta entre **Control Plane** e **Worker Nodes**, seguindo a boa prática.
- **Comando `kubectl get pods --all-namespaces`**:
  - Exibe pods no namespace `kube-system`, incluindo:
    - **CoreDNS**, **etcd**, **kube-apiserver**, **kube-controller-manager**, **kube-scheduler** (relacionados ao **Control Plane**).
    - **kube-proxy**: Três instâncias, uma por nó (um no **Control Plane** e uma em cada **Worker Node**).
    - **local-path-storage**: Relacionado ao armazenamento do Kind.
  - No namespace padrão, `kubectl get pods` retorna "No resources found", pois ainda não há aplicações.
- **Kubeconfig**:
  - O arquivo `~/.kube/config` é atualizado com o contexto `kind-ftr-k8s`, contendo informações de autenticação e o endereço do servidor da API.
  - Todos os comandos `kubectl` usam esse arquivo para se conectar ao cluster.

## Introdução a Namespaces
- **Definição**:
  - Namespaces são divisões **lógicas** no cluster, ao contrário dos nós, que são divisões **físicas**.
  - Usados para organizar recursos (ex.: pods, deployments) por grupos de aplicações ou equipes (ex.: `users`, `payments`).
- **Namespace Padrão**:
  - O namespace `default` é usado automaticamente se nenhum outro for especificado.
  - Não é boa prática rodar aplicações no namespace `default`, pois dificulta a organização e rastreabilidade.
- **Exemplo de Uso**:
  - `kubectl get pods -n kube-system`: Lista pods no namespace `kube-system`, onde residem os componentes do **Control Plane**.
  - `kubectl get pods -n local-path-storage`: Mostra pods específicos desse namespace (ex.: armazenamento do Kind).
  - `kubectl get pods --all-namespaces`: Lista pods de todos os namespaces, incluindo os do **Control Plane** e outros.
- **Importância**:
  - Namespaces ajudam a segregar aplicações, facilitando gerenciamento e evitando conflitos.
  - O **Control Plane** (ex.: pods no `kube-system`) não recebe cargas de trabalho de aplicações, apenas suas próprias responsabilidades.

## Conclusão
A aula avança na configuração de um cluster Kubernetes local com o **Kind**, corrigindo o problema do cluster anterior (nó compartilhado) ao criar um cluster com um **Control Plane** e dois **Worker Nodes** usando um arquivo YAML declarativo. A separação de nós segue as boas práticas, e a introdução de **namespaces** destaca a importância da organização lógica de recursos. Comandos como `kubectl get nodes` e `kubectl get pods --all-namespaces` confirmam o funcionamento do cluster, enquanto o **kubeconfig** garante a conexão. A aula prepara para as próximas sessões, que explorarão a execução de aplicações no cluster, começando a aplicar conceitos práticos.

